# OpenCode Plugin Migration Plan

**Generated by:** GPT-5 Codex Analysis
**Date:** 2025-11-14
**Purpose:** Migrate Claude Code hooks to OpenCode plugins for GPT-5 CLI workflow

---

## Executive Summary

This plan outlines migrating critical Claude Code safety hooks and automation to OpenCode's plugin system. Most safety features can be ported via `tool.execute.before/after` hooks, though some lifecycle features (SessionStart, UserPromptSubmit) have no direct equivalent and are documented as accepted limitations.

**Key Priorities (User-Selected):**
- ‚úÖ Bash safety checks (rm, git, kubectl, terraform blocking)
- ‚úÖ File size guards (prevents reading huge files)
- ‚úÖ Auto-formatting (YAML, Terraform post-edit)
- ‚ùå SessionStart auto-loading (accepted limitation)
- ‚ùå UserPromptSubmit skill activation (manual invocation)

**Target Location:** `~/.dotfiles/opencode/plugin/` (source in dotfiles, symlinked to `~/.config/opencode/plugin/` for OpenCode runtime)

---

## OpenCode Plugin System Overview

### Architecture
- Plugins are async TypeScript/JavaScript modules in `.opencode/plugin/` or `~/.config/opencode/plugin/`
- Export a `Plugin` function returning a `Hooks` object
- Receive context: `{project, directory, worktree, client, $}`
- `$` provides Bun shell API for command execution

### Available Hooks

| Hook | Trigger | Use Case |
|------|---------|----------|
| `tool.execute.before` | Before any tool runs | Block/validate/modify tool calls |
| `tool.execute.after` | After tool completes | Post-processing, formatting |
| `event` | System events | Session lifecycle, notifications |
| `chat.message` | Chat messages | Message interception (limited docs) |
| `config` | Configuration | Custom settings |
| `tool` | Tool registration | Add custom tools |

### Event Types
- `session.idle`, `session.start` (limited)
- `permission.ask`, `permission.updated`
- `message.*` (various message events)

---

## Current Claude Code Hooks Inventory

### Location
All hooks defined in: `nix/home/claude/settings.json:22`

### Hook Categories

#### 1. Notification Hooks (2 hooks)
- **notification_hook.sh** - Desktop alerts via `terminal-notifier` or ntfy
- **stop_hook.sh** - Task completion notifications

#### 2. Session Hooks (1 hook)
- **SessionStart** - Auto-injects superpowers skill documentation

#### 3. User Input Hooks (1 hook)
- **UserPromptSubmit** - Skill auto-activation via `skill_activation_hook.py`

#### 4. PreToolUse Hooks (10 hooks)

**Bash Safety Bundle:**
- `bash_hook.py` - Composite safety checker
- `rm_block_hook.py` - Prevents rm, enforces TRASH pattern
- `git_add_block_hook.py` - Blocks dangerous git add patterns
- `git_checkout_safety_hook.py` - Prevents destructive checkouts
- `git_commit_block_hook.py` - Git commit speed bump
- `kubectl_safety_hook.py` - Blocks kubectl destructive operations
- `terraform_safety_hook.py` - Prevents terraform apply/destroy
- `env_file_protection_hook.py` - Protects .env files

**Other Guards:**
- `file_size_conditional_hook.py` - Read tool: blocks large files
- `pretask_subtask_flag.py` - Task tool: creates flag before execution
- `grep_block_hook.py` - Grep tool: enforces ripgrep
- `claude_md_block_hook.py` - Write/Edit: prevents CLAUDE.md writes

#### 5. PostToolUse Hooks (2 hooks)
- `~/.bin/format.sh` - Auto-formats YAML/Terraform files
- `posttask_subtask_flag.py` - Task tool: removes flag after execution

---

## Migration Mapping

### ‚úÖ Direct Migration (Full Support)

| Claude Hook | OpenCode Implementation | Complexity |
|-------------|------------------------|------------|
| Bash safety bundle (rm/git/kubectl/terraform/env) | `tool.execute.before` for `tool === "bash"` | Medium |
| `file_size_conditional_hook.py` | `tool.execute.before` for `tool === "read"` | Medium |
| `grep_block_hook.py` | `tool.execute.before` for bash grep commands | Low |
| `claude_md_block_hook.py` | `tool.execute.before` for write/edit tools | Low |
| `~/.bin/format.sh` | `tool.execute.after` for write/edit tools | Medium |
| Task flag hooks | `tool.execute.before/after` for `tool === "task"` | Medium |

### ‚ö†Ô∏è Partial Support (Workarounds)

| Claude Hook | Challenge | Workaround |
|-------------|-----------|------------|
| Notification hooks | No direct Notification event | Use `event` hook for `session.idle` + `permission.ask` |

### ‚ùå No Direct Equivalent (Accepted Limitations)

| Claude Hook | Gap | Alternative |
|-------------|-----|-------------|
| SessionStart (superpowers) | No session lifecycle hooks | Manual documentation / custom command |
| UserPromptSubmit (skill activation) | Cannot intercept user prompts | Manual skill invocation |

---

## Implementation Plan

### Phase 0: Correctness Fixes (Blockers Discovered During Review)

1. **Hook Argument Usage**
   - `tool.execute.before` currently references `output.args`, but no `output` object exists until the tool finishes. Update the plan to inspect `input.args` (request payload) in the before-hook and reserve `result`/`output` for the after-hook. This is required for every guard (bash, file-size, CLAUDE.md) to run at all.

2. **Auto-Format Invocation**
   - The post-hook feeds `output.args` to `format.sh`, but write/edit tools often do not expose a single `file_path`. Adjust the plan so Phase¬†1 captures the actual touched files (e.g., via tool metadata or `git status --porcelain`) and pass that list to the formatter. Also guard `format.sh` calls with try/catch so edits do not fail if formatting cannot identify a file.

3. **File-Size Guard Shelling**
   - The current sketch shells out with ``$`wc -l < ${fullPath}`` without quoting, which breaks on whitespace and enables injection. Update Phase¬†1 tasks to compute line counts via Node streams (preferred) or run `wc -l` with proper argument passing (`$` helper supports `$`command`${fullPath}` without redirection). Confirm the plan emphasizes secure path handling.

4. **Task Flag Cleanup**
   - `.opencode_in_subtask.flag` is only removed in `tool.execute.after`, so crashes leave the flag behind and permanently relax the guard. Modify Phase¬†2 to wrap Task execution in a `try/finally` equivalent (add an `event` listener, or eagerly delete the flag before returning) so failure paths reset the state.

5. **State Storage Alternative (Open Question)**
   - Evaluate replacing the sentinel file with in-memory plugin state or OpenCode config storage. Document decision and add tests covering concurrent subtasks if multiple Task invocations run in parallel.

### Phase 1: Core Safety Plugin (`global-safety.ts`)

**Purpose:** Consolidate all critical safety checks into one plugin

**Hooks:** `tool.execute.before`, `tool.execute.after`

**Features:**

1. **Bash Safety (tool.execute.before)**
   - Block `rm` commands ‚Üí suggest TRASH/ pattern
   - Block `git add ./-A/--all` ‚Üí suggest specific files or `git add -u`
   - Block `git checkout` with uncommitted changes ‚Üí suggest stash
   - Block `kubectl delete/destroy` ‚Üí require manual confirmation
   - Block `terraform apply/destroy` ‚Üí require manual confirmation
   - Block `.env` file access in commands

2. **File Size Guard (tool.execute.before)**
   - Check if reading file via Read tool
   - Inspect file size via `fs.stat` + line count via `wc -l`
   - Check for `.opencode_in_subtask.flag` to determine context
   - Main agent: block >500 lines
   - Sub-agent: block >10k lines
   - Allow binary files

3. **CLAUDE.md Guard (tool.execute.before)**
   - Check Write/Edit tool operations
   - Block if `filePath` matches `CLAUDE.md`
   - Suggest editing `AGENTS.md` and symlinking to `CLAUDE.md`

4. **Grep Enforcement (tool.execute.before)**
   - Check bash commands for `grep` usage
   - Block and suggest using `rg` (ripgrep) instead

5. **Auto-Formatting (tool.execute.after)**
   - Trigger on Write/Edit tool completion
   - Shell out to `~/.bin/format.sh` with tool args
   - Apply yamlfmt for YAML files
   - Apply terraform fmt for .tf/.hcl files
   - Add EOF newline if missing
   - Remove trailing whitespace

**Implementation Sketch:**

```typescript
import { Plugin } from "@opencode-ai/plugin";
import { promises as fs } from "node:fs";
import path from "node:path";

export const GlobalSafety: Plugin = async ({ $, directory, client }) => {
  const flag = (name: string) => path.join(directory, `.${name}`);

  const checkRm = (command: string): string | null => {
    if (/\brm\s/.test(command)) {
      return "‚ùå Blocked: Instead of 'rm':\n" +
             "- MOVE files using `mv` to the TRASH/ directory\n" +
             "- Add entry to TRASH-FILES.md with reason";
    }
    return null;
  };

  const checkGitAdd = async (command: string): Promise<string | null> => {
    if (/git\s+add\s+(\.|-A|--all)/.test(command)) {
      return "‚ùå Blocked: Dangerous git add pattern\n" +
             "Use: git add <specific-files> or git add -u\n" +
             "Reason: Prevents accidental staging of unwanted files";
    }
    return null;
  };

  const checkKubectl = (command: string): string | null => {
    if (/kubectl\s+(delete|destroy)/.test(command)) {
      return "‚ö†Ô∏è  Blocked: Destructive kubectl operation\n" +
             "Run manually if you're absolutely sure";
    }
    return null;
  };

  const checkTerraform = (command: string): string | null => {
    if (/terraform\s+(apply|destroy)/.test(command)) {
      return "‚ö†Ô∏è  Blocked: Destructive terraform operation\n" +
             "Run manually with explicit approval";
    }
    return null;
  };

  const checkEnv = (command: string): string | null => {
    if (/\.env/.test(command)) {
      return "üîí Blocked: .env file access\n" +
             "Protect secrets from accidental exposure";
    }
    return null;
  };

  const checkGrep = (command: string): string | null => {
    if (/\bgrep\s/.test(command) && !/\brg\s/.test(command)) {
      return "üí° Suggestion: Use 'rg' (ripgrep) instead of 'grep'\n" +
             "It's faster and respects .gitignore";
    }
    return null;
  };

  const enforceFileSize = async (
    filePath: string | undefined,
    args: any,
    directory: string,
    flagFn: (name: string) => string
  ): Promise<void> => {
    if (!filePath) return;

    const fullPath = path.isAbsolute(filePath)
      ? filePath
      : path.join(directory, filePath);

    // Check if binary (allow)
    const isBinary = /\.(png|jpg|jpeg|gif|pdf|zip|tar|gz)$/i.test(filePath);
    if (isBinary) return;

    // Check context
    const inSubtask = await fs.access(flagFn("opencode_in_subtask.flag"))
      .then(() => true)
      .catch(() => false);

    const limit = inSubtask ? 10000 : 500;

    // Count lines
    const lineCount = parseInt(
      (await $`wc -l < ${fullPath}`.text()).trim(),
      10
    );

    if (lineCount > limit) {
      throw new Error(
        `üìè File too large: ${lineCount} lines (limit: ${limit})\n` +
        `Use Task tool with subagent for large file analysis\n` +
        `File: ${filePath}`
      );
    }
  };

  const isClaudeMD = (filePath: string | undefined): boolean => {
    return filePath?.endsWith("CLAUDE.md") || filePath?.includes("/CLAUDE.md") || false;
  };

  return {
    "tool.execute.before": async (input, output) => {
      // Bash safety checks
      if (input.tool === "bash") {
        const command = output.args?.command ?? "";
        const blockers = [
          checkRm(command),
          await checkGitAdd(command),
          checkKubectl(command),
          checkTerraform(command),
          checkEnv(command),
          checkGrep(command),
        ].filter(Boolean);

        if (blockers.length > 0) {
          throw new Error(blockers.join("\n\n"));
        }
      }

      // File size guard
      if (input.tool === "read") {
        await enforceFileSize(
          output.args?.file_path,
          output.args,
          directory,
          flag
        );
      }

      // CLAUDE.md guard
      if (["write", "edit"].includes(input.tool ?? "")) {
        if (isClaudeMD(output.args?.file_path)) {
          throw new Error(
            "üìù Blocked: Do not write to CLAUDE.md directly\n" +
            "Instead: Edit AGENTS.md and symlink CLAUDE.md ‚Üí AGENTS.md"
          );
        }
      }
    },

    "tool.execute.after": async (input, output) => {
      // Auto-formatting
      if (["write", "edit"].includes(input.tool ?? "")) {
        const toolInput = JSON.stringify({ tool_input: output.args });
        await $.raw`~/.bin/format.sh <<'JSON'\n${toolInput}\nJSON`;
      }
    },
  };
};
```

**Testing Strategy:**
1. Test rm blocking: `rm file.txt` ‚Üí should block
2. Test git add blocking: `git add .` ‚Üí should block
3. Test kubectl blocking: `kubectl delete pod foo` ‚Üí should block
4. Test terraform blocking: `terraform apply` ‚Üí should block
5. Test file size with 600-line file ‚Üí should block
6. Test CLAUDE.md write blocking ‚Üí should block
7. Test formatting after YAML edit ‚Üí should format
8. Test allowed operations still work

**Automated Tests to Deliver:**
- Implement Bun-based unit tests under `plugins/__tests__/global-safety.test.ts` that mock `tool.execute.before/after` inputs and assert the guard logic blocks or allows commands as expected.
- Add integration tests that spawn OpenCode in dry-run mode (if available) or simulate tool invocations via helper harness to verify formatter execution and aggregated error messaging.

**Complexity:** Medium (requires command parsing, file I/O, subprocess calls)

---

### Phase 2: Task Context Plugin (`task-context.ts`)

**Purpose:** Track sub-agent execution state for file-size context detection

**Hooks:** `tool.execute.before`, `tool.execute.after`

**Features:**
- Create `.opencode_in_subtask.flag` before Task tool executes
- Remove flag after Task completes
- Enables `global-safety.ts` to distinguish main vs sub-agent context

**Implementation Sketch:**

```typescript
import { Plugin } from "@opencode-ai/plugin";
import { promises as fs } from "node:fs";
import path from "node:path";

export const TaskContext: Plugin = async ({ directory }) => {
  const flagFile = path.join(directory, ".opencode_in_subtask.flag");

  return {
    "tool.execute.before": async (input) => {
      if (input.tool === "task") {
        await fs.writeFile(flagFile, new Date().toISOString(), "utf-8");
      }
    },

    "tool.execute.after": async (input) => {
      if (input.tool === "task") {
        await fs.unlink(flagFile).catch(() => {}); // Ignore if doesn't exist
      }
    },
  };
};
```

**Testing Strategy:**
1. Trigger Task tool
2. Verify `.opencode_in_subtask.flag` created before execution
3. Verify flag removed after completion
4. Test file-size limits respect flag (10k vs 500 line threshold)

**Automated Tests to Deliver:**
- Create `plugins/__tests__/task-context.test.ts` covering flag creation/removal, including failure scenarios to ensure `finally` cleanup runs.
- Add concurrency test that simulates overlapping Task invocations to ensure the plugin handles multiple executions without leaking state.

**Complexity:** Low

---

### Phase 3: Notifications Plugin (`notifications.ts`)

**Purpose:** Send desktop notifications for session events

**Hooks:** `event`

**Features:**
- Listen for `session.idle` events
- Listen for `permission.ask` events
- Send notifications via `terminal-notifier` (macOS) or ntfy.sh

**Implementation Sketch:**

```typescript
import { Plugin } from "@opencode-ai/plugin";

export const Notifications: Plugin = async ({ $ }) => {
  const notify = async (title: string, message: string) => {
    try {
      // macOS notification
      await $`terminal-notifier -title ${title} -message ${message}`;
    } catch {
      // Fallback to ntfy (if configured)
      const ntfyUrl = process.env.NTFY_URL;
      if (ntfyUrl) {
        await fetch(ntfyUrl, {
          method: "POST",
          body: `${title}: ${message}`,
        });
      }
    }
  };

  return {
    event: async (event) => {
      if (event.type === "session.idle") {
        await notify("OpenCode", "Session is idle");
      }

      if (event.type === "permission.ask") {
        await notify("OpenCode", "Permission requested");
      }
    },
  };
};
```

**Limitations:**
- Cannot distinguish between Claude's Notification vs Stop events
- Relies on OpenCode's event system semantics (less granular)

**Testing Strategy:**
1. Trigger session idle ‚Üí verify notification
2. Trigger permission request ‚Üí verify notification
3. Test fallback to ntfy if terminal-notifier unavailable

**Automated Tests to Deliver:**
- Write `plugins/__tests__/notifications.test.ts` that stubs the `$` shell helper and asserts the correct notification commands fire for `session.idle` and `permission.ask` events.
- Include error-path tests that simulate terminal-notifier failure and confirm the ntfy fallback executes without throwing.

**Complexity:** Low

---

### Phase 4: Validation & Testing

#### 1. Tool Identifier Validation

**Critical:** Must confirm exact tool naming conventions

**Steps:**
1. Start OpenCode in sandbox project
2. Use various tools (Bash, Read, Write, Edit, Task)
3. Add debug logging in plugin to print `input.tool` values
4. Update plugin code with correct identifiers

**Expected identifiers (to confirm):**
- `bash` or `Bash`?
- `read` or `Read`?
- `write` or `Write`?
- `edit` or `Edit`?
- `task` or `Task`?

#### 2. Integration Testing

**Test Suite:**

1. **Bash Safety**
   - ‚úì Block: `rm file.txt`
   - ‚úì Block: `git add .`
   - ‚úì Block: `git add -A`
   - ‚úì Block: `kubectl delete pod foo`
   - ‚úì Block: `terraform apply`
   - ‚úì Block: `cat .env`
   - ‚úì Allow: `git add specific-file.txt`
   - ‚úì Allow: `mv file.txt TRASH/`

2. **File Size Guard**
   - ‚úì Block reading 600-line file (main agent)
   - ‚úì Allow reading 600-line file (sub-agent)
   - ‚úì Block reading 15k-line file (sub-agent)
   - ‚úì Allow binary files regardless of size

3. **CLAUDE.md Guard**
   - ‚úì Block: Write to `CLAUDE.md`
   - ‚úì Block: Edit to `project/CLAUDE.md`
   - ‚úì Allow: Write to `AGENTS.md`

4. **Auto-Formatting**
   - ‚úì Write YAML file ‚Üí verify yamlfmt runs
   - ‚úì Edit .tf file ‚Üí verify terraform fmt runs
   - ‚úì Verify no double-formatting on successive edits

5. **Task Context**
   - ‚úì Task starts ‚Üí flag created
   - ‚úì Task completes ‚Üí flag removed
   - ‚úì File size limits respect flag state

6. **Notifications**
   - ‚úì Session idle ‚Üí notification sent
   - ‚úì Permission request ‚Üí notification sent

#### 3. Error Handling

**Test Scenarios:**
- Plugin throws exception ‚Üí verify user sees actionable error
- Format script missing ‚Üí verify graceful degradation
- Flag file permissions issue ‚Üí verify error message
- Network failure (ntfy) ‚Üí verify silent fallback

#### 4. Performance

**Metrics:**
- Plugin execution time < 100ms for most operations
- File size checks should be fast (avoid reading entire file)
- Formatting should be async/non-blocking if possible

---

## Setup Instructions

### 1. Prerequisites

```bash
# Install OpenCode CLI (if not already)
npm install -g @opencode-ai/cli

# Install plugin types
npm install -g @opencode-ai/plugin

# Verify Bun runtime (required for $ shell)
bun --version

# Ensure format script exists
ls ~/.bin/format.sh
```

### 2. Create Plugin Directory

```bash
# Create source directory in dotfiles repo
mkdir -p ~/.dotfiles/opencode/plugin
cd ~/.dotfiles/opencode/plugin
```

Home Manager links this directory into `~/.config/opencode/plugin` via `nix/home/symlinks.nix`:

```nix
".config/opencode/plugin" = {
  enable = true;
  source = config.lib.file.mkOutOfStoreSymlink "${config.home.homeDirectory}/.dotfiles/opencode/plugin";
};
```

### 3. Initialize TypeScript Project

```bash
cat > package.json <<'EOF'
{
  "name": "opencode-plugins",
  "version": "1.0.0",
  "type": "module",
  "dependencies": {
    "@opencode-ai/plugin": "latest"
  },
  "devDependencies": {
    "@types/node": "latest",
    "typescript": "latest"
  }
}
EOF

cat > tsconfig.json <<'EOF'
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "outDir": "./dist"
  },
  "include": ["*.ts"]
}
EOF

npm install
```

### 4. Create Plugins

Create files in `~/.dotfiles/opencode/plugin` (symlinked to `~/.config/opencode/plugin`):
- `global-safety.ts` (from Phase 1 implementation)
- `task-context.ts` (from Phase 2 implementation)
- `notifications.ts` (from Phase 3 implementation)

### 5. Compile Plugins

```bash
npx tsc
```

### 6. Configure OpenCode

> **Home-Manager Source of Truth:** These dotfiles manage OpenCode via Nix Home Manager. Any new settings (e.g., enabling plugins, configuring notification defaults) must be added to the appropriate module under `nix/home/` and rolled out with `hms`. Avoid hand-editing `~/.config/opencode/opencode.json`, since those changes will be overwritten on the next rebuild.

Add the configuration to the Home-Manager module that renders `~/.config/opencode/opencode.json`, then run `hms` to apply. The generated file should look like:

```json
{
  "plugins": {
    "global-safety": { "enabled": true },
    "task-context": { "enabled": true },
    "notifications": { "enabled": true }
  }
}
```

### 6a. Provide OpenAI API Key

> **Secret Management via Home Manager:** Inject the OpenAI key declaratively‚Äînever hard-code it into `opencode.json`. Use the Home-Manager secret management flow you already rely on (e.g. `sops-nix`, `agenix`, or `home.file` pointing at an encrypted path).

1. Store the key in an encrypted secret file (e.g. `secrets/openai.key`) managed by your existing Nix secret tooling.
2. In the Home-Manager module that renders OpenCode settings, export an environment variable such as `OPENAI_API_KEY` pointing to that secret (via `home.sessionVariables` or `programs.opencode.settings.env`).
3. Reference the variable in the generated OpenCode config, for example:

   ```jsonc
   {
     "providers": {
       "openai": {
         "api_key_env": "OPENAI_API_KEY"
       }
     }
   }
   ```

4. Run `hms` so the config and exported env var land under `~/.config/opencode/` and the key becomes available to the CLI.

### 7. Test Installation

```bash
# Start OpenCode in test project
cd /tmp/test-project
opencode

# Try blocked command
> rm test.txt

# Should see blocking message
```

---

## Open Questions & Risks

### Critical Unknowns

1. **Tool Identifier Casing**
   - **Question:** Are tool names `bash`/`read`/`write` or `Bash`/`Read`/`Write`?
   - **Impact:** Mismatches will silently bypass all checks
   - **Mitigation:** Add debug logging and validate in Phase 4

2. **Error Propagation**
   - **Question:** Does `throw new Error()` in plugin actually block tool execution?
   - **Impact:** If not, safety checks are ineffective
   - **Mitigation:** Test thoroughly with dangerous commands in sandbox

3. **Tool Args Structure**
   - **Question:** What's the exact structure of `output.args` for each tool?
   - **Impact:** May need to adjust property access (`file_path` vs `filePath`)
   - **Mitigation:** Log full args structure during validation

### Medium Risks

4. **Format Script Dependency**
   - **Risk:** `~/.bin/format.sh` may not exist or may fail
   - **Impact:** Auto-formatting fails silently
   - **Mitigation:** Add try/catch and fallback to basic formatting

5. **Skill Activation Gap**
   - **Risk:** No automatic skill activation means reduced productivity
   - **Impact:** User must remember to invoke skills manually
   - **Mitigation:** Create custom commands or macros for common skills

6. **Notification Granularity**
   - **Risk:** `session.idle` may not map well to Claude's Notification events
   - **Impact:** Notifications may be less useful
   - **Mitigation:** Monitor actual behavior and adjust triggers

### Low Risks

7. **Plugin Performance**
   - **Risk:** Synchronous file I/O may slow tool execution
   - **Impact:** Slight UX degradation
   - **Mitigation:** Optimize file checks, use caching if needed

8. **Cross-Platform Compatibility**
   - **Risk:** `terminal-notifier` is macOS-only
   - **Impact:** Notifications won't work on Linux
   - **Mitigation:** Already have ntfy fallback

---

## Alternative Approaches

### Monolithic vs Modular

**Current Plan:** Single `global-safety.ts` plugin

**Alternative:** Split into separate plugins
- `bash-safety.ts`
- `file-guard.ts`
- `write-guard.ts`
- `auto-format.ts`

**Pros:**
- Better fault isolation
- Can enable/disable subsets
- Easier to maintain individually
- Clearer ownership

**Cons:**
- More overhead (multiple plugin initializations)
- Harder to share state (flag file utilities)
- More config entries

**Recommendation:** Start monolithic, split if:
- Plugin becomes >500 lines
- Want to disable specific checks on certain machines
- Need different teams to maintain different checks

### Shell Script vs Pure TypeScript

**Current Plan:** Shell out to `~/.bin/format.sh`

**Alternative:** Port formatting logic to pure TypeScript
```typescript
const format = async (filePath: string) => {
  if (filePath.endsWith('.yaml') || filePath.endsWith('.yml')) {
    await $`yamlfmt -w ${filePath}`;
  }
  if (filePath.endsWith('.tf') || filePath.endsWith('.hcl')) {
    await $`terraform fmt ${filePath}`;
  }
  // Add EOF newline, remove trailing whitespace in TS
};
```

**Pros:**
- No external script dependency
- Easier to debug
- More portable

**Cons:**
- Code duplication (format.sh already exists)
- More complex implementation
- Still depends on yamlfmt/terraform binaries

**Recommendation:** Keep shell script initially, consider porting if:
- format.sh becomes unreliable
- Need Windows support
- Want to add complex formatting logic

---

## Next Steps

### Week 1: Foundation
- [ ] Validate tool identifier casing via debug plugin
- [ ] Implement `global-safety.ts` with all Bash safety checks
- [ ] Implement `task-context.ts` for flag management
- [ ] Write initial test suite

### Week 2: Integration
- [ ] Implement file-size guard in `global-safety.ts`
- [ ] Implement CLAUDE.md guard in `global-safety.ts`
- [ ] Implement auto-formatting in `global-safety.ts`
- [ ] Run full integration test suite

### Week 3: Polish
- [ ] Implement `notifications.ts`
- [ ] Add error handling and graceful degradation
- [ ] Optimize performance (file checks, caching)
- [ ] Document plugin configuration options

### Week 4: Deployment
- [ ] Deploy to `~/.config/opencode/plugin/`
- [ ] Enable in `opencode.json`
- [ ] Monitor for issues in daily use
- [ ] Iterate based on feedback

---

## Success Metrics

### Critical (Must Have)
- ‚úÖ `rm` commands blocked 100% of time
- ‚úÖ Dangerous `git add` patterns blocked 100% of time
- ‚úÖ Files >500 lines blocked for main agent
- ‚úÖ CLAUDE.md writes blocked 100% of time

### Important (Should Have)
- ‚úÖ kubectl/terraform operations blocked
- ‚úÖ YAML/Terraform files auto-formatted
- ‚úÖ Notifications delivered for key events
- ‚úÖ Plugin execution time <100ms average

### Nice to Have (Could Have)
- ‚úÖ Sub-agent file size limits working
- ‚úÖ Grep enforcement suggesting ripgrep
- ‚úÖ Custom skill activation commands

---

## Maintenance Plan

### Regular Reviews
- **Weekly:** Monitor plugin errors and UX issues
- **Monthly:** Review blocked commands to tune sensitivity
- **Quarterly:** Evaluate new OpenCode plugin capabilities

### Update Triggers
- OpenCode releases new hook types ‚Üí assess migration opportunities
- New safety requirements ‚Üí extend `global-safety.ts`
- Performance issues ‚Üí optimize or split plugins

### Rollback Plan
If plugins cause critical issues:
1. Disable via `opencode.json`: `"enabled": false`
2. Remove from plugin directory
3. Fall back to manual safety practices
4. Debug offline and re-deploy

---

## References

- **OpenCode Plugin Docs:** https://opencode.ai/docs/plugins/
- **Current Claude Hooks:** `nix/home/claude/settings.json:22`
- **Format Script:** `~/.bin/format.sh`
- **OpenCode SDK Types:** `@opencode-ai/plugin` package
- **Bun Shell Docs:** https://bun.sh/docs/api/shell

---

## Appendix: Complete Code Examples

See implementation sketches in:
- Phase 1: `global-safety.ts`
- Phase 2: `task-context.ts`
- Phase 3: `notifications.ts`

**End of Plan**
