# OpenCode Plugin Migration Plan

**Generated by:** GPT-5 Codex Analysis
**Date:** 2025-11-14
**Purpose:** Migrate Claude Code hooks to OpenCode plugins for GPT-5 CLI workflow

---

## Executive Summary

This plan outlines migrating critical Claude Code safety hooks and automation to OpenCode's plugin system. Most safety features can be ported via `tool.execute.before/after` hooks, though some lifecycle features (SessionStart, UserPromptSubmit) have no direct equivalent and are documented as accepted limitations.

**Key Priorities (User-Selected):**
- ‚úÖ Bash safety checks (rm, git, kubectl, terraform blocking)
- ‚úÖ File size guards (prevents reading huge files)
- ‚úÖ Auto-formatting (YAML, Terraform post-edit)
- ‚ùå SessionStart auto-loading (accepted limitation)
- ‚ùå UserPromptSubmit skill activation (manual invocation)

**Target Location:** `~/.dotfiles/opencode/plugin/` (source in dotfiles, symlinked to `~/.config/opencode/plugin/` for OpenCode runtime)

---

## OpenCode Plugin System Overview

### Architecture
- Plugins are async TypeScript/JavaScript modules in `.opencode/plugin/` or `~/.config/opencode/plugin/`
- Export a `Plugin` function returning a `Hooks` object
- Receive context: `{project, directory, worktree, client, $}`
- `$` provides Bun shell API for command execution

### Available Hooks

| Hook | Trigger | Use Case |
|------|---------|----------|
| `tool.execute.before` | Before any tool runs | Block/validate/modify tool calls |
| `tool.execute.after` | After tool completes | Post-processing, formatting |
| `event` | System events | Session lifecycle, notifications |
| `chat.message` | Chat messages | Message interception (limited docs) |
| `config` | Configuration | Custom settings |
| `tool` | Tool registration | Add custom tools |

### Event Types
- `session.idle`, `session.start` (limited)
- `permission.ask`, `permission.updated`
- `message.*` (various message events)

---

## Current Claude Code Hooks Inventory

### Location
All hooks defined in: `nix/home/claude/settings.json:22`

### Hook Categories

#### 1. Notification Hooks (2 hooks)
- **notification_hook.sh** - Desktop alerts via `terminal-notifier` or ntfy
- **stop_hook.sh** - Task completion notifications

#### 2. Session Hooks (1 hook)
- **SessionStart** - Auto-injects superpowers skill documentation

#### 3. User Input Hooks (1 hook)
- **UserPromptSubmit** - Skill auto-activation via `skill_activation_hook.py`

#### 4. PreToolUse Hooks (10 hooks)

**Bash Safety Hooks (currently configured):**
- `bash_hook.py` - Composite safety checker
- `rm_block_hook.py` - Prevents rm, enforces TRASH pattern
- `git_add_block_hook.py` - Blocks dangerous git add patterns
- `git_checkout_safety_hook.py` - Prevents destructive checkouts
- `kubectl_safety_hook.py` - Blocks kubectl destructive operations

**Not currently wired but available in upstream repo:**
- `git_commit_block_hook.py` - Git commit speed bump
- `terraform_safety_hook.py` - Prevents terraform apply/destroy
- `env_file_protection_hook.py` - Protects .env files

**Other Guards:**
- `file_size_conditional_hook.py` - Read tool: blocks large files
- `pretask_subtask_flag.py` - Task tool: creates flag before execution
- `grep_block_hook.py` - Grep tool: enforces ripgrep
- `claude_md_block_hook.py` - Write/Edit/MultiEdit: prevents CLAUDE.md writes

#### 5. PostToolUse Hooks (2 hooks)
- `~/.bin/format.sh` - Auto-formats YAML/Terraform files
- `posttask_subtask_flag.py` - Task tool: removes flag after execution

---

## Migration Mapping

### ‚úÖ Direct Migration (Full Support)

| Claude Hook | OpenCode Implementation | Complexity |
|-------------|------------------------|------------|
| Bash safety bundle (rm/git/kubectl/terraform/env) | `tool.execute.before` for `tool === "bash"` | Medium |
| `file_size_conditional_hook.py` | `tool.execute.before` for `tool === "read"` | Medium |
| `grep_block_hook.py` | `tool.execute.before` for bash grep commands | Low |
| `claude_md_block_hook.py` | `tool.execute.before` for write/edit/multiedit tools | Low |
| `~/.bin/format.sh` | `tool.execute.after` for write/edit/multiedit tools | Medium |
| Task flag hooks | `tool.execute.before/after` for `tool === "task"` | Medium |

### ‚ö†Ô∏è Partial Support (Workarounds)

| Claude Hook | Challenge | Workaround |
|-------------|-----------|------------|
| Notification hooks | No direct Notification event | Use `event` hook for `session.idle` + `permission.ask` |

### ‚ùå No Direct Equivalent (Accepted Limitations)

| Claude Hook | Gap | Alternative |
|-------------|-----|-------------|
| SessionStart (superpowers) | No session lifecycle hooks | Manual documentation / custom command |
| UserPromptSubmit (skill activation) | Cannot intercept user prompts | Manual skill invocation |

---

## Implementation Plan

### Phase 0: Correctness Fixes (Blockers Discovered During Review)

##### Hook Argument Usage

- `tool.execute.before` currently references `output.args`, but no `output` object exists until the tool finishes. Update the plan to inspect `input.args` (request payload) in the before-hook and reserve `result`/`output` for the after-hook. This is required for every guard (bash, file-size, CLAUDE.md) to run at all.

##### Auto-Format Invocation

- The post-hook feeds `output.args` to `format.sh`, but write/edit/MultiEdit tools often do not expose a single `file_path`. Adjust the plan so Phase¬†1 captures the actual touched files (e.g., via tool metadata or `git status --porcelain`) and invoke `~/.bin/format.sh` once per file using the JSON contract it expects (`{"tool_input":{"file_path":"/abs/path"}}`). Also guard `format.sh` calls with try/catch so edits do not fail if formatting cannot identify a file.

##### File-Size Guard Shelling

- The current sketch shells out with ``$`wc -l < ${fullPath}`` without quoting, which breaks on whitespace and enables injection. Update Phase¬†1 tasks to compute line counts via Node streams (preferred) or run `wc -l` with proper argument passing (`$` helper supports `$`command`${fullPath}` without redirection). Confirm the plan emphasizes secure path handling.

##### Task Flag Cleanup

- `.opencode_in_subtask.flag` is only removed in `tool.execute.after`, so crashes leave the flag behind and permanently relax the guard. Modify Phase¬†2 (done below) to track active Task call IDs and register process-exit cleanup so the flag is cleared even when the Task tool crashes or OpenCode aborts execution.

##### State Storage Alternative (Open Question)

- Evaluate replacing the sentinel file with in-memory plugin state or OpenCode config storage. Document decision and add tests covering concurrent subtasks if multiple Task invocations run in parallel.

### Phase 1: Core Safety Plugin (`global-safety.ts`)

**Purpose:** Consolidate all critical safety checks into one plugin

**Hooks:** `tool.execute.before`, `tool.execute.after`

**Features:**

##### Bash Safety (tool.execute.before)

- Block `rm` commands ‚Üí suggest TRASH/ pattern
- Block `git add ./-A/--all` ‚Üí suggest specific files or `git add -u`
- Block `git checkout` with uncommitted changes ‚Üí suggest stash
- Block `kubectl delete/destroy` ‚Üí require manual confirmation
- Block `terraform apply/destroy` ‚Üí require manual confirmation
- Block `.env` file access in commands

##### File Size Guard (tool.execute.before)

- Check if reading file via Read tool
- Inspect file size via `fs.stat` + line count via `wc -l`
- Check for `.opencode_in_subtask.flag` to determine context
- Main agent: block >500 lines
- Sub-agent: block >10k lines
- Allow binary files

##### CLAUDE.md Guard (tool.execute.before)

- Check Write/Edit/MultiEdit tool operations
- Block if `filePath` matches `CLAUDE.md`
- Suggest editing `AGENTS.md` and symlinking to `CLAUDE.md`

##### Grep Enforcement (tool.execute.before)

- Check bash commands for `grep` usage
- Block and suggest using `rg` (ripgrep) instead

##### Auto-Formatting (tool.execute.after)

- Trigger on Write/Edit/MultiEdit tool completion
- Shell out to `~/.bin/format.sh` with tool args
- Apply yamlfmt for YAML files
- Apply terraform fmt for .tf/.hcl files
- Add EOF newline if missing
- Remove trailing whitespace

**Implementation Sketch:**

```typescript
import type { Plugin } from "@opencode-ai/plugin";
import { promises as fs } from "node:fs";
import path from "node:path";
import { once } from "node:events";

// NOTE: Hook signatures, tool names, and arg shapes are
// illustrative. Confirm them in Phase 4 with a debug plugin
// and align this implementation with the actual types.

export const GlobalSafety: Plugin = async ({ $, directory }) => {
  const flagPath = (name: string) => path.join(directory, `.${name}`);

  const isBinaryPath = (filePath: string) =>
    /\.(png|jpe?g|gif|pdf|zip|tar|gz|tgz|bz2)$/i.test(filePath);

  const isClaudeMD = (filePath: string | undefined): boolean =>
    !!filePath &&
    (filePath.endsWith("CLAUDE.md") || filePath.includes("/CLAUDE.md"));

  const fileExists = async (p: string): Promise<boolean> =>
    fs
      .access(p)
      .then(() => true)
      .catch(() => false);

  const countLinesStreaming = async (
    fullPath: string,
    limit: number,
  ): Promise<number> => {
    const fh = await fs.open(fullPath, "r");
    const stream = fh.createReadStream();
    let lines = 0;

    stream.on("data", (chunk: Buffer) => {
      for (let i = 0; i < chunk.length; i++) {
        if (chunk[i] === 0x0a) {
          lines++;
          if (lines > limit) {
            stream.destroy();
            break;
          }
        }
      }
    });

    await once(stream, "close");
    await fh.close();
    return lines;
  };

  const enforceFileSize = async (filePath: string | undefined) => {
    if (!filePath) return;
    if (isBinaryPath(filePath)) return;

    const fullPath = path.isAbsolute(filePath)
      ? filePath
      : path.join(directory, filePath);

    if (!(await fileExists(fullPath))) return;

    const inSubtask = await fileExists(
      flagPath("opencode_in_subtask.flag"),
    );
    const limit = inSubtask ? 10_000 : 500;

    const lines = await countLinesStreaming(fullPath, limit + 1);

    if (lines > limit) {
      throw new Error(
        [
          `üìè File too large: ${lines} lines (limit: ${limit})`,
          "Use the Task tool + sub-agent for large-file analysis.",
          `File: ${filePath}`,
        ].join("\n"),
      );
    }
  };

  const collectTouchedFiles = (args: any): string[] => {
    const candidates = new Set<string>();

    if (typeof args?.filePath === "string") {
      candidates.add(args.filePath);
    }
    if (typeof args?.file_path === "string") {
      candidates.add(args.file_path);
    }
    if (Array.isArray(args?.files)) {
      for (const f of args.files) {
        if (typeof f === "string") candidates.add(f);
      }
    }

    return [...candidates];
  };

  const formatFiles = async (files: string[]) => {
    if (files.length === 0) return;

    for (const file of files) {
      const fullPath = path.isAbsolute(file)
        ? file
        : path.join(directory, file);

      const payload = JSON.stringify({
        tool_input: { file_path: fullPath },
      });

      try {
        await $`~/.bin/format.sh <<'JSON'\n${payload}\nJSON`;
      } catch (error) {
        console.error("[global-safety] format.sh failed", error);
      }
    }
  };

  const checkBashCommand = async (command: string): Promise<string[]> => {
    const messages: string[] = [];

    if (/\brm\s/.test(command)) {
      messages.push(
        "‚ùå Blocked: 'rm' is not allowed.\n" +
          "Move files to TRASH/ and record them in TRASH-FILES.md instead.",
      );
    }

    if (/git\s+add\s+(\.|-A|--all)\b/.test(command)) {
      messages.push(
        "‚ùå Blocked: Dangerous 'git add' pattern.\n" +
          "Use 'git add <specific-files>' or 'git add -u' instead.",
      );
    }

    if (/git\s+checkout\b/.test(command)) {
      messages.push(
        "‚ö†Ô∏è Blocked: 'git checkout' may discard local changes.\n" +
          "Stash or commit manually, then rerun yourself if desired.",
      );
    }

    if (/kubectl\s+(delete|destroy)\b/.test(command)) {
      messages.push(
        "‚ö†Ô∏è Blocked: Destructive kubectl operation.\n" +
          "Run manually in a terminal if you're sure.",
      );
    }

    if (/terraform\s+(apply|destroy)\b/.test(command)) {
      messages.push(
        "‚ö†Ô∏è Blocked: Destructive terraform operation.\n" +
          "Run manually with explicit approval.",
      );
    }

    if (/\.env\b/.test(command)) {
      messages.push(
        "üîí Blocked: .env file access.\n" +
          "Secrets should not be listed or copied via tools.",
      );
    }

    if (/\bgrep\s/.test(command) && !/\brg\s/.test(command)) {
      messages.push(
        "‚ùå Blocked: 'grep' is disabled.\n" +
          "Use 'rg' (ripgrep) instead; it's faster and respects .gitignore.",
      );
    }

    return messages;
  };

  return {
    "tool.execute.before": async (input: any) => {
      const tool = (input.tool ?? "").toLowerCase();
      const args = input.args ?? {};

      // save args for use in tool.execute.after
      callArgs.set(input.callID, args);

      if (tool === "bash") {
        const command =
          typeof args.command === "string" ? args.command : "";
        const blockers = await checkBashCommand(command);

        if (blockers.length > 0) {
          throw new Error(blockers.join("\n\n"));
        }
      }

      if (tool === "read") {
        await enforceFileSize(args);
      }

      if (["write", "edit", "multiedit"].includes(tool)) {
        const filePath =
          args.filePath ?? args.file_path ?? args.path;
        if (isClaudeMD(filePath)) {
          throw new Error(
            [
              "üìù Blocked: Do not write to CLAUDE.md directly.",
              "Edit AGENTS.md instead and symlink CLAUDE.md ‚Üí AGENTS.md.",
            ].join("\n"),
          );
        }
      }
    },

    "tool.execute.after": async (input: any) => {
      const tool = (input.tool ?? "").toLowerCase();

      if (!["write", "edit", "multiedit"].includes(tool)) {
        callArgs.delete(input.callID);
        return;
      }

      try {
        const args = callArgs.get(input.callID) ?? {};
        const files = collectTouchedFiles(args);
        await formatFiles(files);
      } catch (err) {
        console.error("[global-safety] format failed", err);
      } finally {
        callArgs.delete(input.callID);
      }
    },
  };
};
```

**Testing Strategy:**
1. Test rm blocking: `rm file.txt` ‚Üí should block
2. Test git add blocking: `git add .` ‚Üí should block
3. Test kubectl blocking: `kubectl delete pod foo` ‚Üí should block
4. Test terraform blocking: `terraform apply` ‚Üí should block
5. Test file size with 600-line file ‚Üí should block
6. Test CLAUDE.md write blocking ‚Üí should block
7. Test formatting after YAML edit ‚Üí should format
8. Test allowed operations still work

**Automated Tests to Deliver:**
- Implement Bun-based unit tests under `plugins/__tests__/global-safety.test.ts` that mock `tool.execute.before/after` inputs and assert the guard logic blocks or allows commands as expected.
- Add integration tests that spawn OpenCode in dry-run mode (if available) or simulate tool invocations via helper harness to verify formatter execution and aggregated error messaging.

**Complexity:** Medium (requires command parsing, file I/O, subprocess calls)

---

### Phase 2: Task Context Plugin (`task-context.ts`)

**Purpose:** Track sub-agent execution state for file-size context detection

**Hooks:** `tool.execute.before`, `tool.execute.after`

**Features:**
- Create `.opencode_in_subtask.flag` before Task tool executes
- Track active Task call IDs so multiple subtasks keep the flag set
- Remove the flag in a `finally` equivalent (after-hook + process-exit cleanup) so crashes do not leave it behind
- Enables `global-safety.ts` to distinguish main vs sub-agent context

**Implementation Sketch:**

```typescript
import type { Plugin } from "@opencode-ai/plugin";
import { promises as fs } from "node:fs";
import path from "node:path";

// NOTE: Hook signatures and arg shapes are illustrative.
// Confirm the actual types in Phase 4 and adjust as needed.

export const TaskContext: Plugin = async ({ directory }) => {
  const flagFile = path.join(directory, ".opencode_in_subtask.flag");
  const pendingTasks = new Set<string>();

  const writeFlag = async () => {
    const payload = JSON.stringify(
      { createdAt: new Date().toISOString() },
      null,
      2,
    );
    await fs.writeFile(flagFile, payload, "utf-8");
  };

  const clearFlag = async () => {
    await fs.unlink(flagFile).catch(() => {});
    pendingTasks.clear();
  };

  const clearIfStale = async () => {
    try {
      const stat = await fs.stat(flagFile);
      const ageMs = Date.now() - stat.mtimeMs;
      const oneHour = 60 * 60 * 1000;
      if (ageMs > oneHour) {
        await clearFlag();
      }
    } catch {
      // Flag does not exist or is unreadable; ignore.
    }
  };

  const ensureFlagState = async () => {
    if (pendingTasks.size === 0) {
      await clearFlag();
    } else {
      await writeFlag();
    }
  };

  const teardown = async () => {
    pendingTasks.clear();
    await clearFlag();
  };

  process.once("exit", () => {
    void teardown();
  });

  process.once("SIGINT", () => {
    void teardown();
    process.exit(1);
  });

  return {
    "tool.execute.before": async (input: any) => {
      if (input.tool === "task") {
        await clearIfStale();
        pendingTasks.add(input.callID);
        await writeFlag();
      }
    },

    "tool.execute.after": async (input: any) => {
      if (input.tool === "task") {
        pendingTasks.delete(input.callID);
        await ensureFlagState();
      }
    },
  };
};
```

**Testing Strategy:**
1. Trigger Task tool
2. Verify `.opencode_in_subtask.flag` created before execution
3. Verify flag removed after completion
4. Test file-size limits respect flag (10k vs 500 line threshold)

**Automated Tests to Deliver:**
- Create `plugins/__tests__/task-context.test.ts` covering flag creation/removal, including failure scenarios to ensure `finally` cleanup runs.
- Add concurrency test that simulates overlapping Task invocations to ensure the plugin handles multiple executions without leaking state.

**Complexity:** Low

---

### Phase 3: Notifications Plugin (`notifications.ts`)

**Purpose:** Send desktop notifications for session events

**Hooks:** `event`

**Features:**
- Listen for `session.idle` events
- Listen for `permission.ask` events
- Send notifications via `terminal-notifier` (macOS) or ntfy.sh

**Implementation Sketch:**

```typescript
import { Plugin } from "@opencode-ai/plugin";

export const Notifications: Plugin = async ({ $ }) => {
  const notify = async (title: string, message: string) => {
    try {
      // macOS notification
      await $`terminal-notifier -title ${title} -message ${message}`;
    } catch {
      // Fallback to ntfy (if configured)
      const ntfyUrl = process.env.NTFY_URL;
      if (ntfyUrl) {
        await fetch(ntfyUrl, {
          method: "POST",
          body: `${title}: ${message}`,
        });
      }
    }
  };

  return {
    event: async (event) => {
      if (event.type === "session.idle") {
        await notify("OpenCode", "Session is idle");
      }

      if (event.type === "permission.ask") {
        await notify("OpenCode", "Permission requested");
      }
    },
  };
};
```

**Limitations:**
- Cannot distinguish between Claude's Notification vs Stop events
- Relies on OpenCode's event system semantics (less granular)

**Testing Strategy:**
1. Trigger session idle ‚Üí verify notification
2. Trigger permission request ‚Üí verify notification
3. Test fallback to ntfy if terminal-notifier unavailable

**Automated Tests to Deliver:**
- Write `plugins/__tests__/notifications.test.ts` that stubs the `$` shell helper and asserts the correct notification commands fire for `session.idle` and `permission.ask` events.
- Include error-path tests that simulate terminal-notifier failure and confirm the ntfy fallback executes without throwing.

**Complexity:** Low

---

### Phase 4: Validation & Testing

#### 1. Tool Identifier Validation

**Critical:** Must confirm exact tool naming conventions

**Steps:**
1. Start OpenCode in sandbox project
2. Use various tools (Bash, Read, Write, Edit, Task)
3. Add debug logging in plugin to print `input.tool` values
4. Update plugin code with correct identifiers

**Expected identifiers (to confirm):**
- `bash` or `Bash`?
- `read` or `Read`?
- `write` or `Write`?
- `edit` or `Edit`?
- `task` or `Task`?

#### 2. Integration Testing

**Test Suite:**

##### Bash Safety

- ‚úì Block: `rm file.txt`
- ‚úì Block: `git add .`
- ‚úì Block: `git add -A`
- ‚úì Block: `kubectl delete pod foo`
- ‚úì Block: `terraform apply`
- ‚úì Block: `cat .env`
- ‚úì Allow: `git add specific-file.txt`
- ‚úì Allow: `mv file.txt TRASH/`

##### File Size Guard

- ‚úì Block reading 600-line file (main agent)
- ‚úì Allow reading 600-line file (sub-agent)
- ‚úì Block reading 15k-line file (sub-agent)
- ‚úì Allow binary files regardless of size

##### CLAUDE.md Guard

- ‚úì Block: Write to `CLAUDE.md`
- ‚úì Block: Edit to `project/CLAUDE.md`
- ‚úì Allow: Write to `AGENTS.md`

##### Auto-Formatting

- ‚úì Write YAML file ‚Üí verify yamlfmt runs
- ‚úì Edit .tf file ‚Üí verify terraform fmt runs
- ‚úì Verify no double-formatting on successive edits

##### Task Context

- ‚úì Task starts ‚Üí flag created
- ‚úì Task completes ‚Üí flag removed
- ‚úì File size limits respect flag state

##### Notifications

- ‚úì Session idle ‚Üí notification sent
- ‚úì Permission request ‚Üí notification sent

#### 3. Error Handling

**Test Scenarios:**
- Plugin throws exception ‚Üí verify user sees actionable error
- Format script missing ‚Üí verify graceful degradation
- Flag file permissions issue ‚Üí verify error message
- Network failure (ntfy) ‚Üí verify silent fallback

#### 4. Performance

**Metrics:**
- Plugin execution time < 100ms for most operations
- File size checks should be fast (avoid reading entire file)
- Formatting should be async/non-blocking if possible

---

## Setup Instructions

### 1. Prerequisites

OpenCode itself is already provided declaratively via Home Manager in `nix/home/opencode.nix`. After editing any of the modules below, run `hms` so the CLI, configuration, and symlinks are reconciled. For plugin development, rely on the repo‚Äôs Nix tooling rather than global npm installs:

```bash
# Enter the repo dev shell (add bun/tsc there if they are missing)
nix develop

# Verify Bun runtime (required for the $ helper) and existing formatter script
bun --version
ls ~/.bin/format.sh
```

### 2. Create Plugin Directory

```bash
# Create source directory in dotfiles repo
mkdir -p ~/.dotfiles/opencode/plugin
cd ~/.dotfiles/opencode/plugin
```

Home Manager links this directory into `~/.config/opencode/plugin` via `nix/home/symlinks.nix`:

```nix
".config/opencode/plugin" = {
  enable = true;
  source = config.lib.file.mkOutOfStoreSymlink "${config.home.homeDirectory}/.dotfiles/opencode/plugin";
};
```

### 3. Initialize TypeScript Project

```bash
cat > package.json <<'EOF'
{
  "name": "opencode-plugins",
  "version": "1.0.0",
  "type": "module",
  "dependencies": {
    "@opencode-ai/plugin": "latest"
  },
  "devDependencies": {
    "@types/node": "latest",
    "typescript": "latest"
  }
}
EOF

cat > tsconfig.json <<'EOF'
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "outDir": "./dist"
  },
  "include": ["*.ts"]
}
EOF

npm install
```

### 4. Create Plugins

Create files in `~/.dotfiles/opencode/plugin` (symlinked to `~/.config/opencode/plugin`):
- `global-safety.ts` (from Phase 1 implementation)
- `task-context.ts` (from Phase 2 implementation)
- `notifications.ts` (from Phase 3 implementation)

### 5. Compile Plugins

```bash
npx tsc
```

### 6. Configure OpenCode

> **Home-Manager Source of Truth:** These dotfiles manage OpenCode via Nix Home Manager. All configuration lives in `nix/home/opencode.nix` under `programs.opencode.settings`. Update that module (not the generated `~/.config/opencode/opencode.json`), then run `hms` so the rendered JSON picks up the changes.

For example:

```nix
programs.opencode = {
  enable = true;
  package = inputs.opencode.packages.${pkgs.stdenv.hostPlatform.system}.default;
  rules = builtins.readFile ./claude/memory.md;
  settings = {
    model = "gpt-5.1";
    theme = "catppuccin";
    plugins = {
      "global-safety".enabled = true;
      "task-context".enabled = true;
      "notifications".enabled = true;
    };
  };
};
```

After editing the module run `hms`. The rendered `~/.config/opencode/opencode.json` should contain:

```json
{
  "plugins": {
    "global-safety": { "enabled": true },
    "task-context": { "enabled": true },
    "notifications": { "enabled": true }
  }
}
```

### 6a. Provide OpenAI API Key

> **Secret Management via Home Manager:** Inject the OpenAI key declaratively‚Äînever hard-code it into `opencode.json`. Use the Home-Manager secret management flow you already rely on (e.g. `sops-nix`, `agenix`, or `home.file` pointing at an encrypted path).

1. Store the key in an encrypted secret file (e.g. `secrets/openai.key`) managed by your existing Nix secret tooling.
2. In the Home-Manager module that renders OpenCode settings, export an environment variable such as `OPENAI_API_KEY` pointing to that secret (via `home.sessionVariables` or `programs.opencode.settings.env`).
3. Reference the variable in the generated OpenCode config, for example:

   ```jsonc
   {
     "providers": {
       "openai": {
         "api_key_env": "OPENAI_API_KEY"
       }
     }
   }
   ```

4. Run `hms` so the config and exported env var land under `~/.config/opencode/` and the key becomes available to the CLI.

### 7. Test Installation

```bash
# Start OpenCode in test project
cd /tmp/test-project
opencode

# Try blocked command
> rm test.txt

# Should see blocking message
```

---

## Open Questions & Risks

### Critical Unknowns

##### Tool Identifier Casing

- **Question:** Are tool names `bash`/`read`/`write` or `Bash`/`Read`/`Write`?
- **Impact:** Mismatches will silently bypass all checks
- **Mitigation:** Add debug logging and validate in Phase 4

##### Error Propagation

- **Question:** Does `throw new Error()` in plugin actually block tool execution?
- **Impact:** If not, safety checks are ineffective
- **Mitigation:** Test thoroughly with dangerous commands in sandbox

##### Tool Args Structure

- **Question:** What's the exact structure of `output.args` for each tool?
- **Impact:** May need to adjust property access (`file_path` vs `filePath`)
- **Mitigation:** Log full args structure during validation

### Medium Risks

##### Format Script Dependency

- **Risk:** `~/.bin/format.sh` may not exist or may fail
- **Impact:** Auto-formatting fails silently
- **Mitigation:** Add try/catch and fallback to basic formatting

##### Skill Activation Gap

- **Risk:** No automatic skill activation means reduced productivity
- **Impact:** User must remember to invoke skills manually
- **Mitigation:** Create custom commands or macros for common skills

##### Notification Granularity

- **Risk:** `session.idle` may not map well to Claude's Notification events
- **Impact:** Notifications may be less useful
- **Mitigation:** Monitor actual behavior and adjust triggers

### Low Risks

##### Plugin Performance

- **Risk:** Synchronous file I/O may slow tool execution
- **Impact:** Slight UX degradation
- **Mitigation:** Optimize file checks, use caching if needed

##### Cross-Platform Compatibility

- **Risk:** `terminal-notifier` is macOS-only
- **Impact:** Notifications won't work on Linux
- **Mitigation:** Already have ntfy fallback

---

## Alternative Approaches

### Monolithic vs Modular

**Current Plan:** Single `global-safety.ts` plugin

**Alternative:** Split into separate plugins
- `bash-safety.ts`
- `file-guard.ts`
- `write-guard.ts`
- `auto-format.ts`

**Pros:**
- Better fault isolation
- Can enable/disable subsets
- Easier to maintain individually
- Clearer ownership

**Cons:**
- More overhead (multiple plugin initializations)
- Harder to share state (flag file utilities)
- More config entries

**Recommendation:** Start monolithic, split if:
- Plugin becomes >500 lines
- Want to disable specific checks on certain machines
- Need different teams to maintain different checks

### Shell Script vs Pure TypeScript

**Current Plan:** Shell out to `~/.bin/format.sh`

**Alternative:** Port formatting logic to pure TypeScript
```typescript
const format = async (filePath: string) => {
  if (filePath.endsWith('.yaml') || filePath.endsWith('.yml')) {
    await $`yamlfmt -w ${filePath}`;
  }
  if (filePath.endsWith('.tf') || filePath.endsWith('.hcl')) {
    await $`terraform fmt ${filePath}`;
  }
  // Add EOF newline, remove trailing whitespace in TS
};
```

**Pros:**
- No external script dependency
- Easier to debug
- More portable

**Cons:**
- Code duplication (format.sh already exists)
- More complex implementation
- Still depends on yamlfmt/terraform binaries

**Recommendation:** Keep shell script initially, consider porting if:
- format.sh becomes unreliable
- Need Windows support
- Want to add complex formatting logic

---

## Next Steps

### Week 1: Foundation
- [ ] Validate tool identifier casing via debug plugin
- [ ] Implement `global-safety.ts` with all Bash safety checks
- [ ] Implement `task-context.ts` for flag management
- [ ] Write initial test suite

### Week 2: Integration
- [ ] Implement file-size guard in `global-safety.ts`
- [ ] Implement CLAUDE.md guard in `global-safety.ts`
- [ ] Implement auto-formatting in `global-safety.ts`
- [ ] Run full integration test suite

### Week 3: Polish
- [ ] Implement `notifications.ts`
- [ ] Add error handling and graceful degradation
- [ ] Optimize performance (file checks, caching)
- [ ] Document plugin configuration options

### Week 4: Deployment
- [ ] Deploy to `~/.config/opencode/plugin/`
- [ ] Enable in `opencode.json`
- [ ] Monitor for issues in daily use
- [ ] Iterate based on feedback

---

## Success Metrics

### Critical (Must Have)
- ‚úÖ `rm` commands blocked 100% of time
- ‚úÖ Dangerous `git add` patterns blocked 100% of time
- ‚úÖ Files >500 lines blocked for main agent
- ‚úÖ CLAUDE.md writes blocked 100% of time

### Important (Should Have)
- ‚úÖ kubectl/terraform operations blocked
- ‚úÖ YAML/Terraform files auto-formatted
- ‚úÖ Notifications delivered for key events
- ‚úÖ Plugin execution time <100ms average

### Nice to Have (Could Have)
- ‚úÖ Sub-agent file size limits working
- ‚úÖ Grep enforcement suggesting ripgrep
- ‚úÖ Custom skill activation commands

---

## Maintenance Plan

### Regular Reviews
- **Weekly:** Monitor plugin errors and UX issues
- **Monthly:** Review blocked commands to tune sensitivity
- **Quarterly:** Evaluate new OpenCode plugin capabilities

### Update Triggers
- OpenCode releases new hook types ‚Üí assess migration opportunities
- New safety requirements ‚Üí extend `global-safety.ts`
- Performance issues ‚Üí optimize or split plugins

### Rollback Plan
If plugins cause critical issues:
1. Disable via `opencode.json`: `"enabled": false`
2. Remove from plugin directory
3. Fall back to manual safety practices
4. Debug offline and re-deploy

---

## References

- **OpenCode Plugin Docs:** <https://opencode.ai/docs/plugins/>
- **Current Claude Hooks:** `nix/home/claude/settings.json:22`
- **Format Script:** `~/.bin/format.sh`
- **OpenCode SDK Types:** `@opencode-ai/plugin` package
- **Bun Shell Docs:** <https://bun.sh/docs/api/shell>

---

## Appendix: Complete Code Examples

See implementation sketches in:
- Phase 1: `global-safety.ts`
- Phase 2: `task-context.ts`
- Phase 3: `notifications.ts`

**End of Plan**
