" initial settings  ------------------------------------------------------ "{{{

scriptencoding utf-8
set nocompatible

"}}}

" vim-plug --------------------------------------------------------------- "{{{

if !empty($SUDO_USER)
  " Use sudo user's bundle path
  let bundlepath = "/home/$SUDO_USER/.vim/bundle"
else
  let bundlepath = "~/.vim/bundle"
endif

silent! call plug#begin(bundlepath)

" plugins ---------------------------------------------------------"{{{

if exists(":PlugInstall")
  Plug 'vim-scripts/IndexedSearch'
  if executable("ag")
    Plug 'christoomey/vim-tmux-navigator'
  endif
  Plug 'tpope/vim-surround'
  Plug 'tpope/vim-repeat'
  Plug 'tpope/vim-endwise'
  Plug 'tpope/vim-unimpaired'
  Plug 'tpope/vim-eunuch'
  Plug 'tpope/vim-abolish'
  Plug 'tpope/vim-dispatch'
  Plug 'roman/golden-ratio'
  Plug 'Raimondi/delimitMate'
  Plug 'tpope/vim-commentary', { 'on': '<Plug>Commentary' }
  Plug 'mileszs/ack.vim',      { 'on': 'Ack' }
  Plug 'sjl/gundo.vim',        { 'on': 'GundoToggle' }
  Plug 'junegunn/vim-easy-align'
  Plug 'junegunn/fzf',         { 'do': 'yes \| ./install' }

  " Test if current directory is a git repo. If true, load git plugins
  " NOTE: This means if you cd to a git repo or open a file that's a member
  " of a git repo, these plugins won't activate. I think that's a fair
  " tradeoff for the startup time these plugins add, when working on a remote
  " system.
  silent let o=system('git rev-parse --git-dir >/dev/null 2>&1')
  if !v:shell_error
    Plug 'tpope/vim-fugitive'
    Plug 'airblade/vim-gitgutter'
  endif

  " colorschemes
  Plug 'chriskempson/base16-vim'

  " language-specific bundles
  Plug 'Glench/Vim-Jinja2-Syntax', { 'for': 'jinja' }
  Plug 'avakhov/vim-yaml',         { 'for': 'yaml' }
  Plug 'chase/vim-ansible-yaml',   { 'for': 'ansible' }
  Plug 'LaTeX-Box-Team/LaTeX-Box', { 'for': 'tex' }
  Plug 'tpope/vim-markdown',       { 'for': 'markdown' }
endif

"}}}

silent! call plug#end()

"}}}

" appearance/font -------------------------------------------------------- "{{{
if has("gui_running")
  " Set font and window size based on operating system
  if has ("unix")
    if has ("gui_macvim")
      " Must be MacVim
      set guifont=Monaco:h10
      set noantialias

      " Full screen means FULL screen
      set fuoptions=maxvert,maxhorz
    else
      " Must be Linux
      set guifont=DejaVu\ Sans\ Mono\ 8
    endif
  else
    " Must be Windows
    set guifont=DejaVu\ Sans\ Mono:h9
  endif

  set guioptions-=m  "remove menu bar
  set guioptions-=T  "remove toolbar
  set guioptions-=r  "remove right-hand scroll bar
  set guioptions-=R  "remove right-hand scroll bar for vert split
  set guioptions-=l  "remove left-hand scroll bar
  set guioptions-=L  "remove left-hand scroll bar for vert split
  set guioptions+=c  "use text-based dialogs instead of popups

  " Different cursors for different modes.
  set guicursor=n-c:block-Cursor-blinkon0
  set guicursor+=v:block-vCursor-blinkon0
  " commented out INSERT mode cursor for compatibilty with other colorschemes
  "set guicursor+=i-ci:ver20-iCursor
else
  " This is console Vim.

  " tmux will only forward escape sequences to the terminal if surrounded by a 
  " DCS sequence
  if exists('$TMUX')
    let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
    let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
  else
    let &t_SI = "\<Esc>]50;CursorShape=1\x7"
    let &t_EI = "\<Esc>]50;CursorShape=0\x7"
  endif
endif

set shortmess=atI " Don't show the Vim intro message

"}}}

" colorscheme ------------------------------------------------------------ "{{{
set background=dark

" force terminal Vim to use 256 colors
if !has("gui_running")
  set t_Co=256
  let base16colorspace=256
endif

" try/catch to set colorscheme
" Vim will throw an error if the colorscheme doesn't exist, so we try another
" in the catch block
try
  colorscheme base16-tomorrow
catch /^Vim\%((\a\+)\)\=:E185/
  try
    colorscheme molokai
  catch /^Vim\%((\a\+)\)\=:E185/
    colorscheme desert
  endtry
endtry
"}}}

" statusline settings ---------------------------------------------------- "{{{

set laststatus=2

" Status: {{{
function! Status(winnum)
  let active = a:winnum == winnr()
  let bufnum = winbufnr(a:winnum)

  let stat = ''

  " this function just outputs the content colored by the
  " supplied colorgroup number, e.g. num = 2 -> User2
  " it only colors the input if the window is the currently
  " focused one

  function! Color(active, num, content)
    if a:active
      return '%' . a:num . '*' . a:content . '%*'
    else
      return a:content
    endif
  endfunction

  " this handles alternative statuslines
  let usealt = 0
  let altstat = Color(active, 4, ' »')

  let type = getbufvar(bufnum, '&buftype')
  let name = bufname(bufnum)

  if type ==# 'help'
    let altstat .= ' ' . fnamemodify(name, ':t:r')
    let usealt = 1
  elseif name ==# '__Gundo__'
    let altstat .= ' Gundo'
    let usealt = 1
  elseif name ==# '__Gundo_Preview__'
    let altstat .= ' Gundo Preview'
    let usealt = 1
  endif

  if usealt
    let altstat .= Color(active, 4, ' «')
    return altstat
  endif

  " column
  "   this might seem a bit complicated but all it amounts to is
  "   a calculation to see how much padding should be used for the
  "   column number, so that it lines up nicely with the line numbers

  "   an expression is needed because expressions are evaluated within
  "   the context of the window for which the statusline is being prepared
  "   this is crucial because the line and virtcol functions otherwise
  "   operate on the currently focused window

  function! Column()
    let vc = virtcol('.')
    let ruler_width = max([strlen(line('$')), (&numberwidth - 1)])
    let column_width = strlen(vc)
    let padding = ruler_width - column_width
    let column = ''

    if padding <= 0
      let column .= vc
    else
      " + 1 becuase for some reason vim eats one of the spaces
      let column .= repeat(' ', padding + 1) . vc
    endif

    return column . ' '
  endfunction

  let stat .= '%1*'
  let stat .= '%{Column()}'
  let stat .= '%*'

  " file name
  let stat .= Color(active, 4, active ? ' »' : ' «')
  let stat .= ' %<'
  let stat .= '%f'
  let stat .= ' ' . Color(active, 4, active ? '«' : '»')

  " file modified
  let modified = getbufvar(bufnum, '&modified')
  let stat .= Color(active, 2, modified ? ' +' : '')

  " read only
  let readonly = getbufvar(bufnum, '&readonly')
  let stat .= Color(active, 2, readonly ? ' ‼' : '')

  " paste
  if active && &paste
    let stat .= ' %2*' . 'P' . '%*'
  endif

  " right side
  let stat .= '%='

  " git branch
  if exists('*fugitive#head')
    let head = fugitive#head()

    if empty(head) && exists('*fugitive#detect') && !exists('b:git_dir')
      call fugitive#detect(getcwd())
      let head = fugitive#head()
    endif

    if !empty(head)
      let stat .= Color(active, 3, ' ← ') . head . ' '
    endif
  endif

  return stat
endfunction
" }}}

" Status AutoCMD: {{{

function! s:RefreshStatus()
  for nr in range(1, winnr('$'))
    call setwinvar(nr, '&statusline', '%!Status(' . nr . ')')
  endfor
endfunction

augroup status
  autocmd!
  autocmd VimEnter,WinEnter,BufWinEnter * call <SID>RefreshStatus()
augroup END
" }}}

" Status Colors: {{{
hi User1 ctermfg=33  guifg=#268bd2  ctermbg=19  guibg=#373b41
hi User2 ctermfg=125 guifg=#d33682  ctermbg=19  guibg=#373b41
hi User3 ctermfg=64  guifg=#719e07  ctermbg=19  guibg=#373b41
hi User4 ctermfg=37  guifg=#2aa198  ctermbg=19  guibg=#373b41
" }}}

"}}}

" standard options ------------------------------------------------------- "{{{

set modelines=0
set encoding=utf-8
set scrolloff=5
set showmode
set showcmd
set title
set visualbell
set cursorline
set ttyfast
set lazyredraw
set ruler
set complete-=i     " Searching includes can be slow
set dictionary+=/usr/share/dict/words
if exists("+colorcolumn")
  set colorcolumn=85
endif

" 7.4 has hybrid mode, so set both
" 7.3 has just relative number, so set just that
if v:version >= 703
  set relativenumber
endif
if v:version != 703
  set number
endif

" mapping timeout
set ttimeout
set ttimeoutlen=50
set timeoutlen=1200


" Allow unsaved background buffers and remember marks/undo for them
set hidden

" Jump to the first open window that contains the specified buffer
set switchbuf=useopen

" Auto-reload buffers when files are changed on disk
set autoread

" Wrapping
set wrap
set showbreak=↪\  " Character to precede line wraps
set textwidth=79

" Prevent Vim from clearing the scrollback buffer
" http://www.shallowsky.com/linux/noaltscreen.html
set t_ti= t_te=

"allow backspace to work for indents, between lines, and the start of insert mode
set backspace=indent,eol,start

"see :help fo-table
set formatoptions=qrn1
" Delete comment character when joining commented lines
if v:version > 703 || v:version == 703 && has("patch541")
  set formatoptions+=j
endif

"indent options
set autoindent
set smartindent
set tabstop=2
set shiftwidth=2
set softtabstop=2
set expandtab
set shiftround

"search options
set ignorecase
set smartcase
set incsearch
set nohlsearch
set showmatch

" search forward and backward for selection
function! s:VSetSearch()
  let temp = @s
  norm! gv"sy
  let @/ = '\V' . substitute(escape(@s, '/\'), '\n', '\\n', 'g')
  let @s = temp
endfunction

xnoremap * :<C-u>call <SID>VSetSearch()<CR>/<C-R>=@/<CR><CR>
xnoremap # :<C-u>call <SID>VSetSearch()<CR>?<C-R>=@/<CR><CR>

"matching
runtime macros/matchit.vim

"show formatting characters
set list
set listchars=tab:»\ ,trail:·,extends:❯,precedes:❮
"use vertical line (CTRL-K+VV) for vertical splits
"see :help digraphs
if !has("gui_running")
  set fillchars=vert:┃
endif

"window options
set splitbelow
set splitright

" per-project vimrc files
" useful for specifying things like tabstops
" Disable on Windows since it will complain if you're
" running in a path where it's not allowed.
if !has("win32")
  set exrc    " enable per-directory .vimrc files
  set secure  " disable unsafe commands in local .vimrc files
endif


"}}}

" autocommands ----------------------------------------------------------- "{{{
if has("autocmd")
  " Resize splits when the window is resized
  au VimResized * exe "normal! \<c-w>="
  " turn off PASTE mode when leaving insert mode
  au InsertLeave * set nopaste

  " j2: Jinja2
  augroup ft_j2
    au BufNewFile,BufRead *.j2 set filetype=jinja
  augroup END

  " eyaml: encrypted yaml for Puppet and Hiera
  augroup ft_eyaml
    au BufNewFile,BufRead *.eyaml set filetype=yaml
  augroup END

  " ansible check for playbooks/*
  augroup ft_ansible
    au BufNewFile,BufRead playbooks/*.yml,playbooks/*.yaml set filetype=ansible
    autocmd FileType puppet setlocal iskeyword-=_
  augroup END

  " Set puppet stuff
  augroup ft_puppet
    autocmd FileType puppet setlocal iskeyword-=:
    autocmd FileType puppet setlocal iskeyword-=_
    " Insert a hash rocket with <c-l>
    autocmd FileType puppet imap <c-l> <space>=>
    if exists("g:loaded_easy_align")
      " hash rocket auto-aign (for Puppet)
      autocmd FileType puppet inoremap <silent> => =><Esc>mzvip:EasyAlign/=>/ ig['Comment']<CR>`z$a<Space>
    endif
  augroup END

  augroup ft_git
    autocmd!

    " Place the cursor at the top of the buffer
    autocmd VimEnter .git/COMMIT_EDITMSG exe 'normal! gg'

    " make 3-way diffs easier to navigate
    autocmd User Fugitive nnoremap <leader>2 :diffget //2<CR> :diffupdate<CR>
    autocmd User Fugitive nnoremap <leader>3 :diffget //3<CR> :diffupdate<CR>
    autocmd User Fugitive nnoremap dp dp:diffupdate<CR>
    autocmd User Fugitive nnoremap do do:diffupdate<CR>
  augroup END

  " vim, vim helpfiles
  augroup ft_vim
    autocmd!

    autocmd FileType vim setlocal foldmethod=marker
    autocmd FileType help setlocal textwidth=78
    " use Enter to follow links
    autocmd FileType help nmap <buffer> <CR> <C-]>
    autocmd BufWinEnter *.txt if &ft == 'help' | wincmd J | endif
  augroup END

  " Return to last position when file is reopened
  autocmd BufReadPost *
        \ if line("'\"") > 1 && line("'\"") <= line("$") |
        \   exe "normal! g`\"" |
        \ endif
endif
" }}}

" backup ----------------------------------------------------------------- "{{{
let vimbackupdir = $HOME . '/.vimbackup'
if exists("*mkdir")
  if !isdirectory(vimbackupdir)
    call mkdir(vimbackupdir)
  endif
endif
set backup
set noswapfile
let &backupdir=vimbackupdir
set history=1000

" Make Vim able to edit crontab files again.
set backupskip=/tmp/*,/private/tmp/*"

" undo feature requires > 7.3
if has("undofile")
  let vimundodir = $HOME . '/.vimundo'
  if exists("*mkdir")
    if !isdirectory(vimundodir)
      call mkdir(vimundodir)
    endif
  endif
  set undofile
  let &undodir=vimundodir
  set undolevels=1000
  set undoreload=10000
endif
"}}}

" wildmenu --------------------------------------------------------------- "{{{
set wildmenu
set wildmode=list:longest

set wildignore+=.hg,.svn,CVS                     " Version control
" ignoring .git has
" consequences
set wildignore+=*.aux,*.out,*.toc                " LaTeX intermediate files
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg   " binary images
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest " compiled object files
set wildignore+=*.spl                            " compiled spelling word lists
set wildignore+=tags                             " ctags
set wildignore+=*.sw?                            " Vim swap files
set wildignore+=*.DS_Store                       " OSX bullshit

set wildignore+=*.luac                           " Lua byte code

set wildignore+=migrations                       " Django migrations
set wildignore+=*.pyc                            " Python byte code
"}}}

" mapping ---------------------------------------------------------------- "{{{

let mapleader="\<Space>"

"disable arrow keys
nnoremap <up> <nop>
nnoremap <down> <nop>
nnoremap <left> <nop>
nnoremap <right> <nop>
inoremap <up> <nop>
inoremap <down> <nop>
inoremap <left> <nop>
inoremap <right> <nop>
"Unmap help
inoremap <F1> <nop>
nnoremap <F1> <nop>
vnoremap <F1> <nop>

"up and down work with wrapped lines
nnoremap j gj
nnoremap k gk

" Split line (sister to [J]oin lines)
" The normal use of S is covered by cc, so don't worry about shadowing it.
nnoremap S i<cr><esc><right>

" replace word under cursor
:nnoremap <Leader>s :%s/\<<C-r><C-w>\>/

" F5 = toggle paste mode
nnoremap <F5> :set invpaste paste?<Enter>
inoremap <F5> <C-O><F5>
set pastetoggle=<F5>

" map easier-to-use keys
noremap H ^
noremap L $
vnoremap L g_

" simplify macro playback
nnoremap Q @q

" gi already moves to "last place you exited insert mode", so we'll map gI to
" something similar: move to last change
nnoremap gI `.

" Use Enter to exit normal,visual,command mode
nnoremap <CR> <Esc>
vnoremap <CR> <Esc>gV
onoremap <CR> <Esc>
" Use CTRL-O to create new line in insert mode
inoremap <C-o> <CR>

" Swap colon, semicolon
nnoremap ; :
nnoremap : ;
vnoremap ; :
vnoremap : ;

" sudo save if not root
cnoremap w!! w !sudo tee % >/dev/null <CR> :e! <CR>

" open new vertical window and switch to it
nnoremap <leader>w <C-w>v<C-w>l
" Easy window navigation
" see plugin settings for tmux-navigator below
" also use ALT combos
nnoremap ˙ <C-w>h
nnoremap ∆ <C-w>j
nnoremap ˚ <C-w>k
nnoremap ¬ <C-w>l

" reselect indented text for quick indentation change
vnoremap < <gv
vnoremap > >gv

" Open a Quickfix window for the last search.
nnoremap <silent> <leader>/ :execute 'vimgrep /'.@/.'/g %'<CR>:copen<CR>
"
" Remove trailing whitespace from entire buffer
nnoremap <leader>W :%s/\s\+$//<cr>:let @/=''<CR>

" insert blank line below
nnoremap <CR> o<ESC>

" edit vimrc in new window
nnoremap <leader>ev <C-w>v<C-w>j:e $MYVIMRC<CR>

" open current file's directory
nnoremap <leader>ew :e <C-R>=expand("%:p:h") . "/" <CR>

" insert date
nnoremap <F6> "=strftime("%Y-%m-%d")<CR>P
inoremap <F6> <C-R>=strftime("%Y-%m-%d")<CR>

" :Qargs sets :args to every file that matches the last vimgrep search
command! -nargs=0 -bar Qargs execute 'args' QuickfixFilenames()
function! QuickfixFilenames()
  let buffer_numbers = {}
  for quickfix_item in getqflist()
    let buffer_numbers[quickfix_item['bufnr']] = bufname(quickfix_item['bufnr'])
  endfor
  return join(map(values(buffer_numbers), 'fnameescape(v:val)')) 
endfunction

" Registers -------------------------------------------------------------- "{{{

" Use the OS clipboard by default
set clipboard^=unnamed

" Copy to X11 primary clipboard
map <leader>y "*y

" Paste from unnamed register and fix indentation
nmap <leader>p pV`]=

"}}}

"}}}

" Abbreviations ---------------------------------------------------------- "{{{

iabbrev myName Stephen Price <stephen@stp5.net>

"}}}

" Folding ---------------------------------------------------------------- "{{{
set foldlevelstart=0

" Make the current location sane.
nnoremap <c-cr> zvzt

" Make zO recursively open whatever top level fold we're in, no matter where the
" cursor happens to be.
nnoremap zO zCzO

" Use ,z to "focus" the current fold.
nnoremap <leader>z zMzvzz

function! MyFoldText() " {{{
  let line = getline(v:foldstart)

  let nucolwidth = &fdc + &number * &numberwidth
  let windowwidth = winwidth(0) - nucolwidth - 3
  let foldedlinecount = v:foldend - v:foldstart

  " expand tabs into spaces
  let onetab = strpart('          ', 0, &tabstop)
  let line = substitute(line, '\t', onetab, 'g')

  let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
  let fillcharcount = windowwidth - len(line) - len(foldedlinecount)
  return line . '…' . repeat(" ",fillcharcount) . foldedlinecount . '…' . ' '
endfunction " }}}
set foldtext=MyFoldText()

" }}}

" Plugins ----------------------------------------------------------------"{{{

" sneak -----------------------------------------------------------------"{{{
" enable streak mode
let g:sneak#streak = 1
"}}}

" Gundo -------------------------------------------------------------------"{{{

nnoremap <F4> :GundoToggle<CR>

"}}}

" easy-align --------------------------------------------------------------"{{{
vnoremap <silent> <Enter> :EasyAlign<Enter>
" custom delimiters
let g:easy_align_delimiters = {
      \  '-': { 'pattern': '-',  'left_margin': 0, 'right_margin': 1, 'stick_to_left': 1 }
      \ }
" }}}

" Ack ---------------------------------------------------------------------"{{{
" Use ag if it's in PATH
" https://github.com/ggreer/the_silver_searcher
if executable("ag")
  let g:ackprg = 'ag --nogroup --nocolor --column'
endif

nnoremap <leader>a :Ack!<space>

" Ack motions {{{
" Steve Losh https://github.com/sjl/dotfiles

" Motions to Ack for things.  Works with pretty much everything, including:
"
"   w, W, e, E, b, B, t*, f*, i*, a*, and custom text objects
"
" Awesome.
"
" Note: If the text covered by a motion contains a newline it won't work.  Ack
" searches line-by-line.

" \aiw will search for the word under the cursor
" \aib will search inside braces
nnoremap <silent> \a :set opfunc=<SID>AckMotion<CR>g@
xnoremap <silent> \a :<C-U>call <SID>AckMotion(visualmode())<CR>

function! s:CopyMotionForType(type)
  if a:type ==# 'v'
    silent execute "normal! `<" . a:type . "`>y"
  elseif a:type ==# 'char'
    silent execute "normal! `[v`]y"
  endif
endfunction

function! s:AckMotion(type) abort
  let reg_save = @@

  call s:CopyMotionForType(a:type)

  execute "normal! :Ack! --literal " . shellescape(@@) . "\<cr>"

  let @@ = reg_save
endfunction

" }}}
" }}}

" fugitive ----------------------------------------------------------------"{{{
nnoremap <Leader>gs :Gstatus<CR>
nnoremap <Leader>gd :Gvdiff<CR>
nnoremap <Leader>gb :Gblame<CR>
nnoremap <Leader>gr :Gread<CR>
nnoremap <Leader>gw :Gwrite<CR>
nnoremap <Leader>gc :Gcommit<CR>
nnoremap <Leader>gp :Gpush<CR>
nnoremap <Leader>gl :Gpull<CR>
"}}}

" vim-gitgutter -----------------------------------------------------------"{{{
let g:gitgutter_map_keys = 0
"}}}

" fzf ---------------------------------------------------------------------"{{{

nnoremap <leader><Space> :FZF<enter>

" List of buffers
function! BufList()
  redir => ls
  silent ls
  redir END
  return split(ls, '\n')
endfunction

function! BufOpen(e)
  execute 'buffer '. matchstr(a:e, '^[ 0-9]*')
endfunction

nnoremap <silent> <Leader>b :call fzf#run({
      \   'source':      reverse(BufList()),
      \   'sink':        function('BufOpen'),
      \   'options':     '+m',
      \   'tmux_height': '40%'
      \ })<CR>

"}}}

" tmux-navigator ----------------------------------------------------------"{{{
" If tmux-navigator is loaded
if exists(":TmuxNavigateLeft")
  noremap <silent> <C-h> :TmuxNavigateLeft<cr>
  noremap <silent> <C-j> :TmuxNavigateDown<cr>
  noremap <silent> <C-k> :TmuxNavigateUp<cr>
  noremap <silent> <C-l> :TmuxNavigateRight<cr>
  noremap <silent> <C-\> :TmuxNavigatePrevious<cr>
else
  noremap <C-h> <C-w>h
  noremap <C-j> <C-w>j
  noremap <C-k> <C-w>k
  noremap <C-l> <C-w>l
  noremap <C-\> <C-w><C-p>
endif
"}}}

" vim-commentary ----------------------------------------------------------"{{{
map  gc  <Plug>Commentary
nmap gcc <Plug>CommentaryLine
"}}}

" LaTeX-Box ---------------------------------------------------------------"{{{
let g:LatexBox_latexmk_preview_continuously = 1
let g:LatexBox_viewer = "open -a Skim"
"}}}

"}}}
