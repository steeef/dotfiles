" initial settings  ---------------------------------------------------------- "{{{

scriptencoding utf-8
set nocompatible

"}}}

" python --------------------------------------------------------------------- "{{{

" include python settings
let my_home = expand("$HOME")
if filereadable(my_home . '/.config/nvim/python.vim')
  source ~/.config/nvim/python.vim
endif

"}}}

" vim-plug ------------------------------------------------------------------- "{{{

if has('nvim')
  let bundlepath = "~/.config/nvim/bundle"
else
  let bundlepath = "~/.vim/bundle"
endif

" Ale check
" A flag for detecting if the required features are set.
if has('nvim')
  let s:has_ale_features = has('timers')
else
  " Check if Job and Channel functions are available, instead of the
  " features. This works better on old MacVim versions.
  let s:has_ale_features = has('timers') && exists('*job_start') && exists('*ch_close_in')
endif

silent! call plug#begin(bundlepath)
" plugins ---------------------------------------------------------------------"{{{

if exists(":PlugInstall")
  if !has('nvim')
    " plugins for vanilla Vim
    Plug 'vim-scripts/IndexedSearch'
    Plug 'ConradIrwin/vim-bracketed-paste'
    Plug 'davidhalter/jedi-vim',     { 'for': 'python' }
    Plug 'roman/golden-ratio'
    if executable("tmux")
      Plug 'christoomey/vim-tmux-navigator'
    endif
  else
    " plugins for Neovim
    Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }
    Plug 'zchee/deoplete-jedi'
  endif
  Plug 'tpope/vim-surround'
  Plug 'tpope/vim-repeat'
  Plug 'tpope/vim-endwise'
  Plug 'tpope/vim-fugitive'
  Plug 'tpope/vim-unimpaired'
  Plug 'tpope/vim-abolish'
  Plug 'skywind3000/asyncrun.vim'
  Plug 'tpope/vim-commentary', { 'on': '<Plug>Commentary' }
  Plug '/usr/local/opt/fzf'
  Plug 'junegunn/fzf.vim'
  Plug 'junegunn/vim-easy-align'
  Plug 'airblade/vim-gitgutter'
  Plug 'mtth/scratch.vim',       { 'on': 'Scratch' }
  Plug 'metakirby5/codi.vim',    { 'on': 'Codi' }
  if s:has_ale_features
    Plug 'w0rp/ale',             { 'for': [ 'python',
                                          \ 'ruby',
                                          \ 'sh',
                                          \ 'yaml',
                                          \ 'vim',
                                          \ 'puppet',
                                          \ 'ansible',
                                          \ 'json',
                                          \ 'go',
                                          \ 'markdown',
                                          \ 'html',
                                          \ 'terraform',
                                          \ 'docker',
                                          \ 'lua'] }
  endif

  " colorschemes
  Plug 'chriskempson/base16-vim'

  " language-specific bundles
  Plug 'Glench/Vim-Jinja2-Syntax', { 'for': 'jinja' }
  Plug 'avakhov/vim-yaml',         { 'for': 'yaml' }
  Plug 'chase/vim-ansible-yaml',   { 'for': 'ansible' }
  Plug 'LaTeX-Box-Team/LaTeX-Box', { 'for': 'tex' }
  Plug 'tpope/vim-markdown',       { 'for': 'markdown' }
  Plug 'hashivim/vim-terraform',   { 'for': 'terraform' }
endif

"}}}

silent! call plug#end()

"}}}

" prefs  --------------------------------------------------------------------- "{{{

set modelines=0
set encoding=utf-8
set scrolloff=999
set showmode
set showcmd
set title
set visualbell
set cursorline
set ttyfast
set lazyredraw
set ruler
set complete-=i     " Searching includes can be slow
set dictionary+=/usr/share/dict/words
if exists("+colorcolumn")
  set colorcolumn=85
endif

" 7.4 has hybrid mode, so set both
" 7.3 has just relative number, so set just that
if v:version >= 703
  set relativenumber
endif
if v:version != 703
  set number
endif

" mapping timeout
set ttimeout
set ttimeoutlen=50
set timeoutlen=1200

set shortmess=atI " Don't show the Vim intro message

" Allow unsaved background buffers and remember marks/undo for them
set hidden

" Jump to the first open window that contains the specified buffer
set switchbuf=useopen

" Auto-reload buffers when files are changed on disk
set autoread

" Wrapping
set wrap
set showbreak=↪\  " Character to precede line wraps
set textwidth=79

" Prevent Vim from clearing the scrollback buffer
" http://www.shallowsky.com/linux/noaltscreen.html
set t_ti= t_te=

"allow backspace to work for indents, between lines, and the start of insert mode
set backspace=indent,eol,start

"see :help fo-table
set formatoptions=qrn1
" Delete comment character when joining commented lines
set formatoptions+=j

"indent options
set autoindent
set smartindent
set tabstop=2
set shiftwidth=2
set softtabstop=2
set expandtab
set shiftround

"search options
set ignorecase
set smartcase
set incsearch
set nohlsearch
set showmatch

"matching
runtime macros/matchit.vim

"show formatting characters
set list
set listchars=tab:»\ ,trail:·,extends:❯,precedes:❮

"use vertical line (CTRL-K+VV) for vertical splits
"see :help digraphs
set fillchars=vert:┃

"window options
set splitbelow
set splitright

"use system clipboard for default register
if has("nvim")
  set clipboard+=unnamedplus
else
  set clipboard^=unnamed
endif

" backup --------------------------------------------------------------------- "{{{

let vimbackupdir = $HOME . '/.vimbackup'
if exists("*mkdir")
  if !isdirectory(vimbackupdir)
    call mkdir(vimbackupdir)
  endif
endif
set backup
set noswapfile
let &backupdir=vimbackupdir
set history=1000

" Make Vim able to edit crontab files again.
set backupskip=/tmp/*,/private/tmp/*"

" undo feature requires > 7.3
if has("undofile")
  let vimundodir = $HOME . '/.vimundo'
  if exists("*mkdir")
    if !isdirectory(vimundodir)
      call mkdir(vimundodir)
    endif
  endif
  set undofile
  let &undodir=vimundodir
  set undolevels=1000
  set undoreload=10000
endif

"}}}

" wildmenu ------------------------------------------------------------------- "{{{

set wildmenu
set wildmode=list:longest

set wildignore+=.hg,.svn,CVS                     " Version control
" ignoring .git has
" consequences
set wildignore+=*.aux,*.out,*.toc                " LaTeX intermediate files
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg   " binary images
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest " compiled object files
set wildignore+=*.spl                            " compiled spelling word lists
set wildignore+=tags                             " ctags
set wildignore+=*.sw?                            " Vim swap files
set wildignore+=*.DS_Store                       " OSX bullshit

set wildignore+=*.luac                           " Lua byte code

set wildignore+=migrations                       " Django migrations
set wildignore+=*.pyc                            " Python byte code

"}}}

" folding -------------------------------------------------------------------- "{{{

set foldlevelstart=99

" Make the current location sane.
nnoremap <c-cr> zvzt

" Make zO recursively open whatever top level fold we're in, no matter where the
" cursor happens to be.
nnoremap zO zCzO

function! MyFoldText() " {{{
  let line = getline(v:foldstart)

  let nucolwidth = &fdc + &number * &numberwidth
  let windowwidth = winwidth(0) - nucolwidth - 3
  let foldedlinecount = v:foldend - v:foldstart

  " expand tabs into spaces
  let onetab = strpart('          ', 0, &tabstop)
  let line = substitute(line, '\t', onetab, 'g')

  let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
  let fillcharcount = windowwidth - len(line) - len(foldedlinecount)
  return line . '…' . repeat(" ",fillcharcount) . foldedlinecount . '…' . ' '
endfunction " }}}
set foldtext=MyFoldText()

"}}}

" appearance ----------------------------------------------------------------- "{{{

if has("gui_running")
  " Set font and window size based on operating system
  if has ("unix")
    if has ("gui_macvim")
      " Must be MacVim
      set guifont=Monaco:h10
      set noantialias

      " Full screen means FULL screen
      set fuoptions=maxvert,maxhorz
    else
      " Must be Linux
      set guifont=DejaVu\ Sans\ Mono\ 8
    endif
  else
    " Must be Windows
    set guifont=DejaVu\ Sans\ Mono:h9
  endif

  set guioptions-=m  "remove menu bar
  set guioptions-=T  "remove toolbar
  set guioptions-=r  "remove right-hand scroll bar
  set guioptions-=R  "remove right-hand scroll bar for vert split
  set guioptions-=l  "remove left-hand scroll bar
  set guioptions-=L  "remove left-hand scroll bar for vert split
  set guioptions+=c  "use text-based dialogs instead of popups

  " Different cursors for different modes.
  set guicursor=n-c:block-Cursor-blinkon0
  set guicursor+=v:block-vCursor-blinkon0
  " commented out INSERT mode cursor for compatibilty with other colorschemes
  "set guicursor+=i-ci:ver20-iCursor
else
  " This is console Vim.

  if !has("nvim")
    " tmux will only forward escape sequences to the terminal if surrounded by a 
    " DCS sequence
    if exists('$TMUX')
      let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
      let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
    else
      let &t_SI = "\<Esc>]50;CursorShape=1\x7"
      let &t_EI = "\<Esc>]50;CursorShape=0\x7"
    endif
  endif
endif

"}}}

" colorscheme ---------------------------------------------------------------- "{{{

set background=dark

" force terminal Vim to use 256 colors
set t_Co=256
let base16colorspace=256

" try/catch to set colorscheme
" Vim will throw an error if the colorscheme doesn't exist, so we try another
" in the catch block
try
  colorscheme base16-tomorrow-night
catch /^Vim\%((\a\+)\)\=:E185/
  try
    colorscheme molokai
  catch /^Vim\%((\a\+)\)\=:E185/
    colorscheme desert
  endtry
endtry

"}}}

" statusline settings -------------------------------------------------------- "{{{

set laststatus=2

" Status: {{{
function! Status(winnum)
  let active = a:winnum == winnr()
  let bufnum = winbufnr(a:winnum)

  let stat = ''

  " this function just outputs the content colored by the
  " supplied colorgroup number, e.g. num = 2 -> User2
  " it only colors the input if the window is the currently
  " focused one

  function! Color(active, num, content)
    if a:active
      return '%' . a:num . '*' . a:content . '%*'
    else
      return a:content
    endif
  endfunction

  " this handles alternative statuslines
  let usealt = 0
  let altstat = Color(active, 4, ' »')

  let type = getbufvar(bufnum, '&buftype')
  let name = bufname(bufnum)

  if type ==# 'help'
    let altstat .= ' ' . fnamemodify(name, ':t:r')
    let usealt = 1
  elseif name ==# '__Gundo__'
    let altstat .= ' Gundo'
    let usealt = 1
  elseif name ==# '__Gundo_Preview__'
    let altstat .= ' Gundo Preview'
    let usealt = 1
  endif

  if usealt
    let altstat .= Color(active, 4, ' «')
    return altstat
  endif

  " column
  "   this might seem a bit complicated but all it amounts to is
  "   a calculation to see how much padding should be used for the
  "   column number, so that it lines up nicely with the line numbers

  "   an expression is needed because expressions are evaluated within
  "   the context of the window for which the statusline is being prepared
  "   this is crucial because the line and virtcol functions otherwise
  "   operate on the currently focused window

  function! Column()
    let vc = virtcol('.')
    let ruler_width = max([strlen(line('$')), (&numberwidth - 1)])
    let column_width = strlen(vc)
    let padding = ruler_width - column_width
    let column = ''

    if padding <= 0
      let column .= vc
    else
      " + 1 becuase for some reason vim eats one of the spaces
      let column .= repeat(' ', padding + 1) . vc
    endif

    return column . ' '
  endfunction

  let stat .= '%1*'
  let stat .= '%{Column()}'
  let stat .= '%*'

  " file name
  let stat .= Color(active, 4, active ? ' »' : ' «')
  let stat .= ' %<'
  let stat .= '%f'
  let stat .= ' ' . Color(active, 4, active ? '«' : '»')

  " file modified
  let modified = getbufvar(bufnum, '&modified')
  let stat .= Color(active, 2, modified ? ' +' : '')

  " read only
  let readonly = getbufvar(bufnum, '&readonly')
  let stat .= Color(active, 2, readonly ? ' ‼' : '')

  " paste
  if active && &paste
    let stat .= ' %2*' . 'P' . '%*'
  endif

  " right side
  let stat .= '%='

  " git branch
  if exists('*fugitive#head')
    let head = fugitive#head()

    if empty(head) && exists('*fugitive#detect') && !exists('b:git_dir')
      call fugitive#detect(getcwd())
      let head = fugitive#head()
    endif

    if !empty(head)
      let stat .= Color(active, 3, ' ← ') . head . ' '
    endif
  endif

  return stat
endfunction
" }}}

" Status AutoCMD: {{{

function! s:RefreshStatus()
  for nr in range(1, winnr('$'))
    call setwinvar(nr, '&statusline', '%!Status(' . nr . ')')
  endfor
endfunction

augroup status
  autocmd!
  autocmd VimEnter,WinEnter,BufWinEnter * call <SID>RefreshStatus()
augroup END

" }}}

" Status Colors: {{{

hi User1 ctermfg=33  guifg=#268bd2  ctermbg=19  guibg=#373b41
hi User2 ctermfg=125 guifg=#d33682  ctermbg=19  guibg=#373b41
hi User3 ctermfg=64  guifg=#719e07  ctermbg=19  guibg=#373b41
hi User4 ctermfg=37  guifg=#2aa198  ctermbg=19  guibg=#373b41

" }}}

"}}}

" autocommands --------------------------------------------------------------- "{{{

if has("autocmd")
  " Resize splits when the window is resized
  au VimResized * exe "normal! \<c-w>="
  " turn off PASTE mode when leaving insert mode
  au InsertLeave * set nopaste

  augroup ft_git
    autocmd!
    " Place the cursor at the top of the buffer
    autocmd VimEnter .git/COMMIT_EDITMSG exe 'normal! gg'
    autocmd VimEnter .git/COMMIT_EDITMSG startinsert
  augroup END

  autocmd FileType python setlocal colorcolumn=120

  " vim, vim helpfiles
  augroup ft_vim
    autocmd!

    autocmd FileType vim setlocal foldmethod=marker
    autocmd FileType help setlocal textwidth=78
    " use Enter to follow links
    autocmd FileType help nmap <buffer> <CR> <C-]>
    autocmd BufWinEnter *.txt if &ft == 'help' | wincmd J | endif
  augroup END

  " Return to last position when file is reopened
  autocmd BufReadPost *
        \ if line("'\"") > 1 && line("'\"") <= line("$") |
        \   exe "normal! g`\"" |
        \ endif
endif

"}}}

"}}}

" mapping -------------------------------------------------------------------- "{{{

let mapleader="\<Space>"

" Swap colon, semicolon
nnoremap ; :
nnoremap : ;
vnoremap ; :
vnoremap : ;

"up and down work with wrapped lines
nnoremap j gj
nnoremap k gk

" Split line (sister to [J]oin lines)
" The normal use of S is covered by cc, so don't worry about shadowing it.
nnoremap S i<cr><esc><right>

" F5 = toggle paste mode
nnoremap <F5> :set invpaste paste?<Enter>
inoremap <F5> <C-O><F5>
set pastetoggle=<F5>

" simplify macro playback
nnoremap Q @q

" gi already moves to "last place you exited insert mode", so we'll map gI to
" something similar: move to last change
nnoremap gI `.

" Use Enter to exit normal,visual,command mode
nnoremap <CR> <Esc>
vnoremap <CR> <Esc>gV
onoremap <CR> <Esc>
" Use CTRL-O to create new line in insert mode
inoremap <C-o> <CR>

" sudo save if not root
cnoremap w!! w !sudo tee % >/dev/null <CR> :e! <CR>

" reselect indented text for quick indentation change
vnoremap < <gv
vnoremap > >gv

" Remove trailing whitespace from entire buffer
nnoremap <leader>W :%s/\s\+$//<cr>:let @/=''<CR>

" insert blank line below
nnoremap <CR> o<ESC>

" Quickly edit/reload this configuration file
if has("nvim")
  nnoremap <leader>ev <C-w>v:e $MYVIMRC<CR>
else
  nnoremap <leader>ev <C-w>v<C-w>l:e $MYVIMRC<CR>
endif
nnoremap <leader>sv :so $MYVIMRC<CR>

" windows -------------------------------------------------------------------- "{{{

" open new vertical window and switch to it
if has("nvim")
  nnoremap <leader>w :vnew<CR>
else
  nnoremap <leader>w <C-w>v<C-w>l
endif

if exists(":TmuxNavigateLeft")
  " Easy window navigation
  " see plugin settings for tmux-navigator below
  " also use ALT combos
  nnoremap ˙ <C-w>h
  nnoremap ∆ <C-w>j
  nnoremap ˚ <C-w>k
  nnoremap ¬ <C-w>l
else
  nnoremap <C-h> <C-w>h
  nnoremap <C-j> <C-w>j
  nnoremap <C-k> <C-w>k
  nnoremap <C-l> <C-w>l
  nnoremap <C-\> <C-w><C-p>
endif

"}}}

" terminal ------------------------------------------------------------------- "{{{

if has("nvim")
  " huge scrollback buffer
  let g:terminal_scrollback_buffer_size = 100000
  set scrollback=100000

  " open new vertical window for terminal and switch to it
  nnoremap <leader>t :vnew<CR>:terminal<CR>

  " Start in insert mode
  autocmd BufWinEnter,WinEnter term://* startinsert
  " Leave in normal mode
  autocmd BufLeave term://* stopinsert

  " allow modification of terminal content, disable number lines
  autocmd TermOpen * setlocal modifiable nonumber norelativenumber

  " go back to normal mode
  tnoremap <C-Space> <C-\><C-n>

  " Easier motion between buffers
  tmap <C-j> <C-Space><C-j>
  tmap <C-h> <C-Space><C-h>
  tmap <C-l> <C-Space><C-l>
  tmap <C-k> <C-Space><C-k>

 " make vim behave a bit more like a terminal
  noremap <C-d> :q<CR>

 " neovim-remote
  " https://github.com/mhinz/neovim-remote
  if executable("nvr")
    let $VISUAL = 'nvr -cc split --remote-wait'
  endif
endif

"}}}

" fasd integration ----------------------------------------------------------- "{{{

if executable("fasd")
  " Z - cd to recent / frequent directories
  command! -nargs=* Z :call Z(<f-args>)
  function! Z(...)
    let cmd = 'fasd -d -e printf'
    for arg in a:000
      let cmd = cmd . ' ' . arg
    endfor
    let path = system(cmd)
    if isdirectory(path)
      echo path
      exec 'cd ' . "\"${path}\""
    endif
  endfunction

  nnoremap <leader>z :Z<Space>
endif

"}}}

" plugin settings ------------------------------------------------------------ "{{{

" easy-align ------------------------------------------------------------------"{{{

vnoremap <silent> <Enter> :EasyAlign<Enter>

"}}}

" vim-gitgutter ---------------------------------------------------------------"{{{

let g:gitgutter_map_keys = 0
nmap ]c <Plug>GitGutterNextHunk
nmap [c <Plug>GitGutterPrevHunk
nmap <Leader>c <Plug>GitGutterStageHunk
nmap <Leader>u <Plug>GitGutterUndoHunk

"}}}

" fzf -------------------------------------------------------------------------"{{{
" Files with preview
command! -bang -nargs=? -complete=dir Files
  \ call fzf#vim#files(<q-args>, fzf#vim#with_preview(), <bang>0)

" Augmenting Ag command using fzf#vim#with_preview function
"   * fzf#vim#with_preview([[options], preview window, [toggle keys...]])
"     * For syntax-highlighting, Ruby and any of the following tools are required:
"       - Highlight: http://www.andre-simon.de/doku/highlight/en/highlight.php
"       - CodeRay: http://coderay.rubychan.de/
"       - Rouge: https://github.com/jneen/rouge
"
"   :Ag  - Start fzf with hidden preview window that can be enabled with "?" key
"   :Ag! - Start fzf in fullscreen and display the preview window above
command! -bang -nargs=* Ag
  \ call fzf#vim#ag(<q-args>,
  \                 <bang>0 ? fzf#vim#with_preview('up:60%')
  \                         : fzf#vim#with_preview('right:50%:hidden', '?'),
  \                 <bang>0)

nnoremap <leader><Space> :Files<enter>
nnoremap <silent> <Leader>b :Buffers<enter>
nnoremap <silent> <Leader>h :History:<enter>

nnoremap <leader>a :Ag<Space>
nnoremap <silent> <Leader>A :Ag <C-R><C-W><CR>

" use rg
let g:rg_command = '
  \ rg --column --line-number --no-heading --fixed-strings --ignore-case --no-ignore --hidden --follow --color "always"
  \ -g "*.{js,json,php,md,styl,jade,html,config,py,cpp,c,go,hs,rb,conf}"
  \ -g "!{.git,node_modules,vendor}/*" '

"}}}

" vim-commentary --------------------------------------------------------------"{{{
map  gc  <Plug>Commentary
nmap gcc <Plug>CommentaryLine
"}}}

" LaTeX-Box -------------------------------------------------------------------"{{{
let g:LatexBox_latexmk_preview_continuously = 1
let g:LatexBox_viewer = "open -a Skim"
"}}}

" ale -------------------------------------------------------------------------"{{{
let g:ale_python_pylint_options = '--max-line-length=120'
let g:ale_python_flake8_args = '--max-line-length=120'
let g:ale_python_flake8_use_global = 1
"}}}

" deoplete --------------------------------------------------------------------"{{{
let g:deoplete#enable_at_startup = 1
"}}}

" tmux-navigator --------------------------------------------------------------"{{{
" If tmux-navigator is loaded
if exists(":TmuxNavigateLeft")
  noremap <silent> <C-h> :TmuxNavigateLeft<cr>
  noremap <silent> <C-j> :TmuxNavigateDown<cr>
  noremap <silent> <C-k> :TmuxNavigateUp<cr>
  noremap <silent> <C-l> :TmuxNavigateRight<cr>
  noremap <silent> <C-\> :TmuxNavigatePrevious<cr>
else
  noremap <C-h> <C-w>h
  noremap <C-j> <C-w>j
  noremap <C-k> <C-w>k
  noremap <C-l> <C-w>l
  noremap <C-\> <C-w><C-p>
endif
"}}}

" Asyncrun --------------------------------------------------------------------"{{{

nnoremap <leader>p :AsyncRun git push<Enter>

  " open quickfix when commands posted
if exists("*asyncrun#quickfix_toggle")
  autocmd QuickFixCmdPost * call asyncrun#quickfix_toggle(8, 1)
else
  autocmd QuickFixCmdPost * botright copen 8
endif

"}}}

" GoldenRatio -----------------------------------------------------------------"{{{

let g:golden_ratio_autocommand = 0
nnoremap <leader>m :GoldenRatioToggle<Enter>

"}}}

" scratch ---------------------------------------------------------------------"{{{

let g:scratch_insert_autohide = 0
nnoremap gs :Scratch<Enter>

"}}}

" fugitive --------------------------------------------------------------------"{{{

nnoremap <leader>g :Gstatus<Enter>

"}}}
"
" vim-terraform ---------------------------------------------------------------"{{{

let g:terraform_fmt_on_save = 1
let g:terraform_align = 1
autocmd FileType terraform setlocal commentstring=#%s

"}}}

"}}}
